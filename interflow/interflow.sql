/*
Navicat MySQL Data Transfer

Source Server         : LM
Source Server Version : 50513
Source Host           : localhost:3306
Source Database       : interflow

Target Server Type    : MYSQL
Target Server Version : 50513
File Encoding         : 65001

Date: 2018-05-21 13:47:08
*/

SET FOREIGN_KEY_CHECKS=0;

-- ----------------------------
-- Table structure for `answer`
-- ----------------------------
DROP TABLE IF EXISTS `answer`;
CREATE TABLE `answer` (
  `aid` varchar(50) NOT NULL,
  `content` varchar(1000) DEFAULT NULL,
  `supportCnt` int(11) DEFAULT '0',
  `opposeCnt` int(11) DEFAULT '0',
  `answerTo` varchar(50) DEFAULT NULL,
  `time` varchar(50) DEFAULT NULL,
  `uid` varchar(50) DEFAULT NULL,
  `accept` int(11) NOT NULL DEFAULT '0' COMMENT '是否采纳',
  `praise` int(11) NOT NULL DEFAULT '0',
  `username` varchar(20) DEFAULT NULL,
  `qid` varchar(50) DEFAULT NULL,
  `toid` varchar(50) DEFAULT NULL,
  `questiontitle` varchar(50) DEFAULT NULL,
  `userface` varchar(50) DEFAULT NULL,
  PRIMARY KEY (`aid`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of answer
-- ----------------------------
INSERT INTO `answer` VALUES ('d158081b-e001-499b-b3d6-35054b40ef64', '埃杜阿多', '0', '0', 'MM', '2018-05-16 18:15:43', '456', '0', '0', 'LM', 'e0195736-f372-4625-8180-d175d7a4c28c', '789', 'hahah', null);
INSERT INTO `answer` VALUES ('e0c77c07-b8f7-4bea-bf87-cf6236bec232', 'cccccccccccc', '0', '0', 'MM', '2018-05-16 18:02:50', '456', '0', '0', 'LM', 'e0195736-f372-4625-8180-d175d7a4c28c', '789', 'hahah', null);

-- ----------------------------
-- Table structure for `board`
-- ----------------------------
DROP TABLE IF EXISTS `board`;
CREATE TABLE `board` (
  `bid` varchar(50) NOT NULL,
  `title` varchar(100) DEFAULT NULL,
  `content` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`bid`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of board
-- ----------------------------

-- ----------------------------
-- Table structure for `forum`
-- ----------------------------
DROP TABLE IF EXISTS `forum`;
CREATE TABLE `forum` (
  `fid` varchar(50) NOT NULL,
  `title` varchar(255) DEFAULT NULL,
  `content` text,
  `type` int(11) DEFAULT NULL,
  `uid` varchar(50) DEFAULT NULL,
  `status` int(11) DEFAULT NULL,
  `time` varchar(50) DEFAULT NULL,
  PRIMARY KEY (`fid`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of forum
-- ----------------------------
INSERT INTO `forum` VALUES ('2d869735-4eeb-4093-aba3-6442840a59af', 'JAVA开发', 'java技术交流', '1', '789', '1', '2018-05-16 10:11:55');
INSERT INTO `forum` VALUES ('37be2631-5180-4bde-bc6a-f0e98201173c', 'happy', 'fine', '2', '123', '1', '2018-05-16 11:29:29');
INSERT INTO `forum` VALUES ('39c84611-d107-4da0-964a-7183cc5e1024', '大学生活', '分享你的大学生活', '2', '789', '1', '2018-05-16 10:09:13');
INSERT INTO `forum` VALUES ('478f5098-87fa-4278-ab29-a9afa1682ea3', 'java', '的撒大', '1', '456', '1', '2018-05-21 12:45:33');
INSERT INTO `forum` VALUES ('6ddee1d8-8957-41c7-8554-21a0104c7690', 'C++', 'C++讨论学习', '1', '123', '1', '2018-05-16 10:26:42');
INSERT INTO `forum` VALUES ('744d6133-0e84-48ae-82a1-0282268b63eb', 'XXXXXX', 'XXXXX', '2', '456', '2', '2018-05-21 12:54:31');
INSERT INTO `forum` VALUES ('900296b3-843a-44de-ad02-74698c0e9378', '周小川指出', '十大', '2', '456', '2', '2018-05-21 13:06:17');
INSERT INTO `forum` VALUES ('e88258ae-e7f5-4e49-819d-c73bd3d47004', 'Python开发', 'python交流', '1', '456', '0', '2018-05-16 15:38:14');

-- ----------------------------
-- Table structure for `friends`
-- ----------------------------
DROP TABLE IF EXISTS `friends`;
CREATE TABLE `friends` (
  `id` varchar(50) NOT NULL,
  `userid` varchar(50) DEFAULT NULL,
  `friendid` varchar(50) DEFAULT NULL,
  `status` int(11) DEFAULT NULL,
  `date` varchar(50) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of friends
-- ----------------------------
INSERT INTO `friends` VALUES ('697492db-61be-4bba-a208-23f146c036c9', '456', '789', '1', '2018-05-16 17:22:08');

-- ----------------------------
-- Table structure for `message`
-- ----------------------------
DROP TABLE IF EXISTS `message`;
CREATE TABLE `message` (
  `id` varchar(50) NOT NULL,
  `time` varchar(50) NOT NULL,
  `content` text NOT NULL,
  `href` varchar(1000) DEFAULT NULL,
  `fromid` varchar(50) NOT NULL,
  `toid` varchar(50) DEFAULT NULL,
  `fromstatus` int(4) NOT NULL DEFAULT '0' COMMENT '来源方状态',
  `tostatus` int(4) NOT NULL DEFAULT '0' COMMENT '到达方状态',
  `type` int(11) DEFAULT '0' COMMENT '类型',
  `fromname` varchar(50) DEFAULT NULL COMMENT '来源方名称',
  `toname` varchar(50) DEFAULT NULL COMMENT '到达方名字',
  `readstatus` int(4) NOT NULL DEFAULT '0',
  `title` varchar(100) DEFAULT NULL,
  `fid` varchar(50) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of message
-- ----------------------------
INSERT INTO `message` VALUES ('0ec7a311-2823-4138-bf28-471c09a83ef9', '2018-05-17 17:08:01', 'LM邀请你聊天', null, '456', '789', '0', '0', '2', 'LM', 'MM', '0', null, null);
INSERT INTO `message` VALUES ('1cb6c22a-fe36-4f15-9ab4-c805b8899c53', '2018-05-16 18:15:43', '埃杜阿多', null, '456', '789', '0', '0', '0', 'LM', 'MM', '1', null, null);
INSERT INTO `message` VALUES ('1e8ea60b-1810-4a20-975f-4a6935f6aadb', '2018-05-17 17:06:58', 'LM邀请你聊天', null, '456', '789', '0', '0', '2', 'LM', 'MM', '0', null, null);
INSERT INTO `message` VALUES ('1fe07f2f-f304-489d-a464-794e9ae67d21', '2018-05-17 17:06:35', 'LM邀请你聊天', null, '456', '789', '0', '0', '2', 'LM', 'MM', '1', null, null);
INSERT INTO `message` VALUES ('2fa12cde-d363-4b76-ac55-cde414f3a12c', '2018-05-16 17:22:14', 'MM同意了你的请求！', null, '789', '456', '0', '0', '0', 'MM', 'LM', '1', null, null);
INSERT INTO `message` VALUES ('3077583b-9eef-44b1-ba43-2f83c5a99b18', '2018-05-21 12:59:44', '您申请的版块被禁用，请联系管理员！', null, '2abe95d2-fa87-4af0-8e3b-b1ca70b9e7b7', '456', '0', '0', '3', '管理员', null, '1', null, null);
INSERT INTO `message` VALUES ('34d7bd1a-da68-4574-9d54-98dd7661e242', '2018-05-16 17:22:08', '你好', null, '456', '789', '0', '0', '1', 'LM', 'MM', '1', null, null);
INSERT INTO `message` VALUES ('50c971ad-05dd-4f97-bcbe-f3db69c86e03', '2018-05-16 18:02:50', 'cccccccccccc', null, '456', '789', '0', '0', '0', 'LM', 'MM', '1', null, null);
INSERT INTO `message` VALUES ('86d97936-907f-446a-bc0f-a1ccf01909c8', '2018-05-21 13:06:40', '您申请的版块被禁用，请联系管理员！:周小川指出', null, '2abe95d2-fa87-4af0-8e3b-b1ca70b9e7b7', '456', '0', '0', '3', '管理员', null, '1', null, null);
INSERT INTO `message` VALUES ('90ca7175-afd4-4b39-afb0-c19fc6b22dc0', '2018-05-17 17:05:29', 'LM邀请你聊天', null, '456', '789', '0', '0', '2', 'LM', 'MM', '1', null, null);
INSERT INTO `message` VALUES ('ae327a13-a574-4696-9029-aeda948a1de2', '2018-05-17 17:00:16', 'LM邀请你聊天', null, '456', '789', '0', '0', '2', 'LM', 'MM', '1', null, null);
INSERT INTO `message` VALUES ('cc237c8e-c352-4c54-8667-294ff97402a5', '2018-05-17 17:06:08', 'LM邀请你聊天', null, '456', '789', '0', '0', '2', 'LM', 'MM', '1', null, null);
INSERT INTO `message` VALUES ('d76b1963-803d-4f0a-88a4-2ef0a0ee340a', '2018-05-17 17:07:36', 'LM邀请你聊天', null, '456', '789', '0', '0', '2', 'LM', 'MM', '0', null, null);
INSERT INTO `message` VALUES ('e23704d2-ac19-4870-9aae-1f1694556986', '2018-05-21 12:46:02', '管理员已同意！', null, '2abe95d2-fa87-4af0-8e3b-b1ca70b9e7b7', '456', '0', '0', '3', '管理员', null, '1', null, null);

-- ----------------------------
-- Table structure for `news`
-- ----------------------------
DROP TABLE IF EXISTS `news`;
CREATE TABLE `news` (
  `nid` varchar(50) NOT NULL,
  `title` varchar(50) DEFAULT NULL,
  `date` varchar(50) DEFAULT NULL,
  `n_id` varchar(50) DEFAULT NULL,
  `type` int(11) DEFAULT '0',
  `url` varchar(255) DEFAULT NULL,
  `source` varchar(50) DEFAULT NULL,
  `imgurl` varchar(255) DEFAULT NULL,
  `readnum` int(11) DEFAULT '0',
  PRIMARY KEY (`nid`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of news
-- ----------------------------
INSERT INTO `news` VALUES ('331baa2e-5805-11e8-a147-000c29753dbb', '涉枪涉毒案大逆转？周立波：我会回来的', '2018-05-15 13:47:25', '331baa2e-5805-11e8-a147-000c29753dbb', '0', 'http://shehui.k618.cn/h1info/201805/t20180510_15915673.html', '看看新闻Knews', 'http://sc3.hao123img.com/fetch_xk/07f84e44ec675b656514d2f988da9fff', '1');
INSERT INTO `news` VALUES ('331c1784-5805-11e8-a147-000c29753dbb', '妻子要先挣钱拒绝生孩子 男子挥刀砍妻子和岳母', '2018-05-15 13:47:23', '331c1784-5805-11e8-a147-000c29753dbb', '0', 'http://shehui.k618.cn/h1info/201805/t20180510_15917626.html', '成都商报(成都)', 'http://sc2.hao123img.com/fetch_xk/cc2108aea3bbec7ccaf9ffccc9cdb139', '1');
INSERT INTO `news` VALUES ('331ccec2-5805-11e8-a147-000c29753dbb', '以色列为伊朗划红线，却让人看不懂，谁才是不请自来的', '2018-05-15 13:44:48', '331ccec2-5805-11e8-a147-000c29753dbb', '0', 'http://bbs.miercn.com/hao123bottom/201805/thread_1623919_1.html', '米尔网', 'http://sc3.hao123img.com/fetch_xk/f4a817f4293d4cf6a9e2f7c7e53a32b0', '0');
INSERT INTO `news` VALUES ('331d3c7c-5805-11e8-a147-000c29753dbb', '付辛博颖儿大婚 伴手礼5999胸针曝光', '2018-05-15 13:45:07', '331d3c7c-5805-11e8-a147-000c29753dbb', '0', 'http://toutiao.china.com/shsy/gundong4/13000238/20180515/32412496.html', '中华网', 'http://sc3.hao123img.com/fetch_xk/778e9c18797920b7f40b2f5e50d2d45a', '1');
INSERT INTO `news` VALUES ('331dc73c-5805-11e8-a147-000c29753dbb', '税延型商业养老保险适用哪些人?税务总局权威解读', '2018-05-15 13:47:24', '331dc73c-5805-11e8-a147-000c29753dbb', '0', 'http://shehui.k618.cn/h1info/201805/t20180510_15916170.html', '澎湃新闻(上海)', 'http://sc4.hao123img.com/fetch_xk/3285d52751c109a9b74e12f3a302f972', '0');
INSERT INTO `news` VALUES ('331e39b0-5805-11e8-a147-000c29753dbb', '河北邯郸两男童遭恶犬袭击 一人左臂几乎被咬烂', '2018-05-15 13:47:30', '331e39b0-5805-11e8-a147-000c29753dbb', '0', 'http://shehui.k618.cn/h1info/201805/t20180509_15907455.html', '大众网(济南)', 'http://sc3.hao123img.com/fetch_xk/6dede85f1965c39fc64c2cdcb9142c06', '0');
INSERT INTO `news` VALUES ('331eb408-5805-11e8-a147-000c29753dbb', '嚯，这两朵奇葩一结盟，就要“武力分裂中国”！', '2018-05-15 13:45:03', '331eb408-5805-11e8-a147-000c29753dbb', '0', 'http://bbs.miercn.com/hao123bottom/201805/thread_1624213_1.html', '米尔网', 'http://sc3.hao123img.com/fetch_xk/4a6ef31e93540bd90f29df0f6a1b93a1', '1');
INSERT INTO `news` VALUES ('331f28ac-5805-11e8-a147-000c29753dbb', '世界杯裁判索贿 沙特足协：已要求取消他执法资格', '2018-05-15 13:45:07', '331f28ac-5805-11e8-a147-000c29753dbb', '0', 'http://toutiao.china.com/shsy/gundong4/13000238/20180515/32412490.html', '中华网', 'http://sc4.hao123img.com/fetch_xk/b7abe617959b553b00dba3fd5431b5e9', '0');
INSERT INTO `news` VALUES ('331fdbb2-5805-11e8-a147-000c29753dbb', 'Uber无人驾驶致死案初查:探测到行人但系统未反应', '2018-05-15 13:47:31', '331fdbb2-5805-11e8-a147-000c29753dbb', '0', 'http://shehui.k618.cn/h1info/201805/t20180508_15899813.html', '澎湃新闻(上海)', 'http://sc1.hao123img.com/fetch_xk/3465c55ed33353e8ba397f0cb5a8cc93', '1');
INSERT INTO `news` VALUES ('332059a2-5805-11e8-a147-000c29753dbb', '昆工：用“硬实力+软纽带”连接世界', '2018-05-15 13:42:53', '332059a2-5805-11e8-a147-000c29753dbb', '0', 'https://mini.eastday.com/a/180515133504783.html?qid=01333', '云南网', 'http://sc3.hao123img.com/fetch_xk/c0ca2609c7a8ac8960f86fa0638af331', '0');
INSERT INTO `news` VALUES ('3320ba0a-5805-11e8-a147-000c29753dbb', '“精日没啥”，罗永浩三观被锤子砸碎了么', '2018-05-15 13:45:02', '3320ba0a-5805-11e8-a147-000c29753dbb', '0', 'http://bbs.miercn.com/hao123bottom/201805/thread_1624203_1.html', '米尔网', 'http://sc2.hao123img.com/fetch_xk/426c183a68c6240e14c6b4e9c02cf1e4', '0');
INSERT INTO `news` VALUES ('332126ac-5805-11e8-a147-000c29753dbb', '今天，中国海军迎来大新闻，国产航母首次海试可能有大惊喜', '2018-05-15 13:44:48', '332126ac-5805-11e8-a147-000c29753dbb', '0', 'http://bbs.miercn.com/hao123bottom/201805/thread_1623921_1.html', '米尔网', 'http://sc4.hao123img.com/fetch_xk/2602df0c792bda6a459156aa3d254ea8', '0');
INSERT INTO `news` VALUES ('3321bc84-5805-11e8-a147-000c29753dbb', '14岁女学生上学途中失联:品学兼优 曾与父母起争执', '2018-05-15 13:47:24', '3321bc84-5805-11e8-a147-000c29753dbb', '0', 'http://shehui.k618.cn/h1info/201805/t20180510_15916642.html', '澎湃新闻(上海)', 'http://sc3.hao123img.com/fetch_xk/24b0d4192dbab5533a5db2b6cb81f117', '0');
INSERT INTO `news` VALUES ('332253ce-5805-11e8-a147-000c29753dbb', '汶川一中学演练应对7级地震 千名学生5分钟疏散', '2018-05-15 13:47:23', '332253ce-5805-11e8-a147-000c29753dbb', '0', 'http://shehui.k618.cn/h1info/201805/t20180510_15915927.html', '华西都市报(四川)', 'http://sc4.hao123img.com/fetch_xk/edebe997f4b37df69a7364a55de2ab61', '0');
INSERT INTO `news` VALUES ('3322c61a-5805-11e8-a147-000c29753dbb', '女婴晚高峰时间紧急转诊 交警为其开辟\"生命通道\"', '2018-05-15 13:47:30', '3322c61a-5805-11e8-a147-000c29753dbb', '0', 'http://shehui.k618.cn/h1info/201805/t20180509_15907361.html', '澎湃新闻(上海)', 'http://sc0.hao123img.com/fetch_xk/8ec06ef3e278b78f4113d2438212e046', '0');
INSERT INTO `news` VALUES ('33232060-5805-11e8-a147-000c29753dbb', '王炸！轰-20前传，国产轰炸机一次看个够', '2018-05-15 13:45:02', '33232060-5805-11e8-a147-000c29753dbb', '0', 'http://bbs.miercn.com/hao123bottom/201805/thread_1624205_1.html', '米尔网', 'http://sc3.hao123img.com/fetch_xk/523960b2d98f58eecefe97f8e7576727', '0');
INSERT INTO `news` VALUES ('3323e22a-5805-11e8-a147-000c29753dbb', '96年浙江&amp;quot;小鲜肉&amp;quot;夺健美冠军 为健身一天吃70个鸡蛋白', '2018-05-15 13:45:09', '3323e22a-5805-11e8-a147-000c29753dbb', '0', 'http://toutiao.china.com/shsy/gundong4/13000238/20180515/32412349.html', '中华网', 'http://sc0.hao123img.com/fetch_xk/96278b9fb0114ce9ac4f80e2d4556936', '0');
INSERT INTO `news` VALUES ('3324435a-5805-11e8-a147-000c29753dbb', '保姆莫焕晶上诉 案件将于5月17日上午9时开庭审理', '2018-05-15 13:45:09', '3324435a-5805-11e8-a147-000c29753dbb', '0', 'http://toutiao.china.com/shsy/gundong4/13000238/20180515/32412364.html', '中华网', 'http://sc2.hao123img.com/fetch_xk/7c8c26258815e1cb8eb59c2236f99f8b', '0');
INSERT INTO `news` VALUES ('3324dc70-5805-11e8-a147-000c29753dbb', '如何帮助吸毒人员回归社会？武汉实行\"社区托管\"', '2018-05-15 13:47:29', '3324dc70-5805-11e8-a147-000c29753dbb', '0', 'http://shehui.k618.cn/h1info/201805/t20180509_15907527.html', '法制日报', 'http://sc2.hao123img.com/fetch_xk/fdec4d6a2eeb4a9728e526655d97facd', '0');
INSERT INTO `news` VALUES ('332550c4-5805-11e8-a147-000c29753dbb', '湖南一校外小卖部被查封：卖学生散烟并提供吸烟房', '2018-05-15 13:47:22', '332550c4-5805-11e8-a147-000c29753dbb', '0', 'http://shehui.k618.cn/h1info/201805/t20180510_15917647.html', '澎湃新闻(上海)', 'http://sc2.hao123img.com/fetch_xk/5f692bc863948242d020f6ea72c85279', '0');
INSERT INTO `news` VALUES ('813222c6-5b41-11e8-ac35-000c29753dbb', '关于Java IO与NIO知识都在这里', '2018-05-19 16:49:10', '9c96d888-009f-4341-b102-a30f53c0916e', '1', null, '掘金', null, '0');
INSERT INTO `news` VALUES ('8300a73a-5b41-11e8-ac35-000c29753dbb', '一篇文章，让你彻底弄懂生产者--消费者问题', '2018-05-19 16:49:10', 'fa445205-c92c-4d20-93ec-e9022966ebc6', '1', null, '掘金', null, '0');
INSERT INTO `news` VALUES ('8371ec06-5b41-11e8-ac35-000c29753dbb', 'Java9后String的空间优化', '2018-05-19 16:49:10', 'e96c5958-9d87-470c-b0b5-ef2e650f052c', '1', null, '掘金', null, '0');
INSERT INTO `news` VALUES ('83f1ddee-5b41-11e8-ac35-000c29753dbb', 'Dubbo入门(2) - 简单实践', '2018-05-19 16:49:10', '511f64f8-e326-437c-ab5a-261dc6bdc732', '1', null, '掘金', null, '0');
INSERT INTO `news` VALUES ('8469c2dc-5b41-11e8-ac35-000c29753dbb', 'Spring整合Quartz分布式调度', '2018-05-19 16:49:10', '907eafb1-2cd6-477c-86b7-3246f1ec7980', '1', null, '掘金', null, '0');
INSERT INTO `news` VALUES ('84d8f5d0-5b41-11e8-ac35-000c29753dbb', 'Spring 数据处理框架的演变', '2018-05-19 16:49:10', '77967888-88b6-49b5-81f4-a5e5b27272f0', '1', null, '掘金', null, '0');
INSERT INTO `news` VALUES ('85302eb8-5b41-11e8-ac35-000c29753dbb', '基于工程经验的『RESTful接口设计规范』', '2018-05-19 16:49:10', '469c779f-0939-450d-9e23-8adb07cc07b2', '1', null, '掘金', null, '0');
INSERT INTO `news` VALUES ('85960b52-5b41-11e8-ac35-000c29753dbb', 'SpringBoot开发案例从0到1构建分布式秒杀系统', '2018-05-19 16:49:10', '7733b042-cb4d-47f1-8480-3b4b271fb7c0', '1', null, '掘金', null, '0');
INSERT INTO `news` VALUES ('861c7516-5b41-11e8-ac35-000c29753dbb', '并发编程 —— 自己写一个异步回调 API', '2018-05-19 16:49:10', '9f51e4ef-a5b7-4c98-93d4-01325b76491c', '1', null, '掘金', null, '0');
INSERT INTO `news` VALUES ('893ce2d0-5b41-11e8-ac35-000c29753dbb', 'Java效率工具之Swagger2', '2018-05-19 16:49:10', '68574070-c8b7-424b-9d92-0d0815215134', '1', null, '掘金', null, '0');
INSERT INTO `news` VALUES ('8a72541e-5b41-11e8-ac35-000c29753dbb', '谈优化：池相关内容', '2018-05-19 16:49:10', '978aeb93-397c-461c-a177-fc94d818811f', '1', null, '掘金', null, '0');

-- ----------------------------
-- Table structure for `notice`
-- ----------------------------
DROP TABLE IF EXISTS `notice`;
CREATE TABLE `notice` (
  `id` varchar(50) NOT NULL,
  `content` text,
  `time` varchar(50) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of notice
-- ----------------------------
INSERT INTO `notice` VALUES ('5c5974c5-cc65-4958-8b93-356bae5bd03b', '本系统在更新状态，请见谅！', '2018-05-06 15:42:08');
INSERT INTO `notice` VALUES ('d2cfbab8-c5ff-4c4b-b7b6-9a878306e407', '欢迎大家来本网站寻找好基友<img src=\"http://localhost:8080/resources/kindeditor/plugins/emoticons/images/42.gif\" alt=\"\" border=\"0\" /><img src=\"http://localhost:8080/resources/kindeditor/plugins/emoticons/images/42.gif\" alt=\"\" border=\"0\" /><img src=\"http://localhost:8080/resources/kindeditor/plugins/emoticons/images/44.gif\" alt=\"\" border=\"0\" /><img src=\"http://localhost:8080/resources/kindeditor/plugins/emoticons/images/82.gif\" alt=\"\" border=\"0\" /><br />', '2018-05-14 10:29:01');

-- ----------------------------
-- Table structure for `nsnews`
-- ----------------------------
DROP TABLE IF EXISTS `nsnews`;
CREATE TABLE `nsnews` (
  `nsid` varchar(50) NOT NULL,
  `title` varchar(50) DEFAULT NULL,
  `content` mediumtext,
  `pic` varchar(50) DEFAULT NULL,
  `date` varchar(0) DEFAULT NULL,
  `views` int(11) DEFAULT NULL,
  `source` varchar(50) DEFAULT NULL,
  `nid` varchar(50) DEFAULT NULL,
  PRIMARY KEY (`nsid`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of nsnews
-- ----------------------------
INSERT INTO `nsnews` VALUES ('469c779f-0939-450d-9e23-8adb07cc07b2', '基于工程经验的『RESTful接口设计规范』', '前言\n这篇文章，主要想总结自己在设计RESTful API的一系列经验于思考。\n有些规范可能与标准规范有所出入，但是所有的考量都是基于『减少重复工作，增加可读性可维护性』而出发的。话说回来，我一直觉得 RESTful API 设计，确实没有很明显的公认规范（如果你是指发明者的那篇论文，估计没多少人详细阅读过，而且其作者只是提出了一系列概念而已）。网上的教程，似乎都是千篇一律的（我严重怀疑：都是 “借鉴or拷贝” 阮一峰老师的那几篇文章），僵硬而且呆板，有点教条化（从来没有人怀疑它们吗，反正我按照这些教条设计API，没有感受到多少乐趣）。\n以上，并不是全部否定，好东西要充分吸收，不好的东西，要融合自己的理解，加以改造。\n对 RESTful API 的认识\n说到这个，似乎又要谈及『RESTful 是对资源的抽象』、『结合了HTTP 的特点』云云。不过这些都是一些没用的套话，没啥营养价值，而我想从另外的角度谈论这个。\n既然是 API，一般都符合 API 的一般模式：\nResultType ApiName(ParamType )\n\n1. 接口参数，即形参。可以是 string，int，以及其他任意可以称之为参数的东西\n2. 接口返回值。可以是 string，int，以及其他任意可以称之为返回值的东西\n3. 接口名（签名)\n我们来看看 RESTful 是如何对应上这个模式的：\nHttpResponse URL(HttpRequest)\n\n1. HttpRequest：包括请求头，URL参数，请求body参数\n2. HttpResponse: 包括响应头，响应的body\n这样来看，RESTful API 无非是一种特殊的API 而已，通用的 API 设计法则，同样适合 RESTful，只不过非变换形式而已。\n那么我们大概有哪些比较通用的标准呢？大概有这些：\n\n接口命名，必须做到清晰。一般来说，做到『动宾短语』即可。\n接口数量，越少越好。三个不如两个，两个不如一个，一个不如没有，最好的 API 就是『没有API』。\n有明确的输入输出。念念不忘必有回响，总是有返回值，告诉调用端，我到底做了什么，做得怎么样，即：反馈。\n\n下面就来看看这些标准，是如何影响下文的内容的，：）。\nURL设计，及其反模式\nURL 就是接口签名，而签名必须做到清晰，没有歧义。\n有统一的前缀 & 版本化\n如果后端架构是服务化的，那么有可能每个服务会对外提供公共的 RESTful API，那么有个统一的前缀格式，会比较好，比如：\n/SERVICE_NAME/v1/users\nor\n/APP_NAME/v2/users\n尽量短小\n同一份资源，可以有不同的路径，去理解它。比如：\nUser -- 1：N --> Server-- 1:N --> Client ... 更加复杂的实体映射关系\n\n1. /users/{user_id}/servers/{server_id}/clients\n2. /clients\n\n一般大家倾向于选项 1（但是实体关联关系特复杂时，会缩短URL），\n不过选项2 也是一个不错的选择，总而言之，口味问题吧。\n数量尽量少\n接口数量越少越好，能合并的接口就尽量合并。比如，这样的情况：\n获取用户列表信息：GET /users\n获取单个用户信息：GET /users/{id}\n\n坦白说，获取一个与获取一批，似乎并没有什么语义上的差别，\n但是后端的同学就不一样了，他可能需要写两个 View Class。\n所以只保留批量的接口，查询一个时，用 URL 参数传递就行了。\n这样的情况：\nPUT /users/{id}\nPUT /users\n\n直接合并到一个接口里面做就行了，PUT 一个 user与 PUT 一群 user，有啥本质的不同吗？\n还有这样极端的情况：\nDELETE /users/{id}\n\n删除一个user与删除一批user，有啥不同？\n如果要一次删除100 个 user，难道让前端同学，调 100 次这个接口？\n多一次调用，就多一次风险（如网络问题），\n这个时候就别守着 RESTful 那些个教条了，接口的可用性、效率性，更加重要。\n\n这个时候，不如设计成这样（至于 DELETE 接口能不能传Request body，这里不讨论）：\nPOST /users_deletion\n{\n    \"user_ids\": [1, 2, 3, 4, 5]\n}\n返回值设计\n前面有说到，HttpResponse中，我们可以利用：\nResponse Headers\n可以做少量文章，如自定义一个Header\n\nStatus Code\n按照基本规范来，该404的404，该200的200\n\nResponse body\n基本都是围绕这个做文章\nResponse body 既要能正常返回信息，出错了也要告诉出错原因（错误码），出错详情。所以我们大概可以设计成这样：\n{\n    是否成功\n    boolean \"is_success\":\n    错误码是多少\n    number|null \"err_code\":\n    错误信息\n    string|null \"err_msg\": \n    错误详情（可选）\n    string|null \"err_detail\":\n    出错的时哪个服务\n    string|null \"provider\": \n    \n    正常返回时的数据\n    \"response_data\": {\n\n    }\n}\n这样，前端调用 API ，就有章法可循了，不至于盲目。\n字段命名规范\n没有很明确的规范，但是尽量跟随数据库的风格，即：下划线风格。\n这样，在 序列化整个 Model 时，也许会很方便。\n其他规范\n接口限流\n参考 GitHub 的风格。\n接口安全\n这个没法系统化，可以参考网络上相关文章。\n', null, null, null, '掘金', '85302eb8-5b41-11e8-ac35-000c29753dbb');
INSERT INTO `nsnews` VALUES ('511f64f8-e326-437c-ab5a-261dc6bdc732', 'Dubbo入门(2) - 简单实践', '\n作者：不洗碗工作室 - Marklux\n出处：Dubbo入门(2) - 简单实践\n版权归作者所有，转载请注明出处\n\n在了解什么是分布式框架之后，我们需要上手实践一下，来了解整个系统是如何运作起来的。\n本文抱着学习的目的来尝试使用dubbo搭建一个简单的分布式服务，并且使用dubbokeeper来进行服务的监控。\n参考自：聊聊dubbo和最简单的dubbo教程\n准备工作\n在正式使用dubbo之前，需要准备两样东西：\n1. 服务注册中心(ZooKeeper)\ndubbo的消费方和服务方都需要在一个统一的注册中心进行注册才能使用，搭建一个zookeeper即可，当然你也可以使用其他的注册中心并集成进去。\nzookeeper的搭建流程很简单，参考此文即可（仅仅是最简单的单机版，并不复杂）。\n2. 服务监控中心（dubbokeeper）\n为了监控整个分布式服务的运行情况，最好能够有一个可视化的管理和监控应用，这里选用由dubboclub团队开发的dubbokeeper，当然也可以使用dubbo官方的dubboadmin项目。\n由于dubbokeeper的部署有些复杂，在这里还是简要的描述一下，注意监控软件并不是必要的，但是为了能够看到服务运行的效果，建议还是部署一个。\n部署流程参考此文\n下载源码\n首先需要获取dubbokeeper的源码，可以从github上获取，git地址：\nhttps://github.com/dubboclub/dubbokeeper\n下面我们假设将dubbokeeper克隆到了~/dubbokeeper这个目录下。\n修改配置\n在此之前，首先需要确定你要使用何种数据库，dubbokeeper目前支持MySQL,MongoDB和Lucene三种数据储存方案，我们以MySQL为例进行部署。\n首先要填写~/dubbokeeper/conf/dubbo-mysql.properties配置文件，下面给出比较重要的配置项说明：\ndubbo.registry.address=zookeeper://localhost:2181 #注册中心地址\ndubbo.protocol.name=dubbo\ndubbo.protocol.port=20884 #dubbo服务端口\ndubbo.monitor.mysql.url=jdbc:mysql://localhost:3306/dubbo-monitor #mysql服务地址\ndubbo.monitor.mysql.username=root\ndubbo.monitor.mysql.password=secret #用户名及密码\n接下来要填写~/dubbokeeper/dubbokeeper-ui/src/main/resources/dubbo.properties配置文件中的注册中心和网络服务器类型等参数。\n初始化数据库\n创建一个mysql数据库，并运行~/dubbokeeper/doc/storage/mysql/sql/application.sql创建表结构。\n编译打包\n执行~/dubbokeeper/install-mysql.sh进行打包，最终会生成target输出目录。\n启动部署\n这一步要启动几个服务后才能去部署应用，注意顺序\n首先需要启动zookeeper服务，注意端口的配置要和配置文件一致。\n接下来执行target目录下的mysql-dubbokeeper-server/bin/start-mysql.sh启动储存服务。\n最后将target目录下的mysql-dubbokeeper-ui中的war包复制到tomcat（自己部署）的webapps目录下，启动tomcat便会自动进行解压和安装，之后访问http://localhost:8080/dubbokeeper-ui-1.0.1看到如下界面，即为安装成功。\n\n创建API\n现在正式开始编程。我们将使用dubbo创建一个非常简单的、只有一个消费者和一个服务提供方的例子。\n首先第一步是创建双方都需要依赖的数据交换定义，通过一个interface来实现。\n创建maven项目msa-demo-api，pom.xml文件内容如下：\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n    <groupId>com.marklux</groupId>\n    <artifactId>msa-demo-api</artifactId>\n    <version>1.0-SNAPSHOT</version>\n    <packaging>pom</packaging>\n\n    <properties>\n        <motan.version>0.3.0</motan.version>\n        <!-- 在阿里巴巴内部广泛使用的GA版本为：2.4.9，强烈推荐此版本 -->\n        <dubbo.version>2.5.3</dubbo.version>\n        <dubbox.version>2.8.4</dubbox.version>\n        <spring.version>4.3.6.RELEASE</spring.version>\n        <java.version>1.7</java.version>\n        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n    </properties>\n\n    <dependencies>\n        <dependency>\n            <groupId>com.alibaba</groupId>\n            <artifactId>dubbo</artifactId>\n            <version>2.5.3</version>\n            <exclusions>\n                <exclusion>\n                    <groupId>org.springframework</groupId>\n                    <artifactId>spring</artifactId>\n                </exclusion>\n            </exclusions>\n        </dependency>\n        <dependency>\n            <groupId>com.github.sgroschupf</groupId>\n            <artifactId>zkclient</artifactId>\n            <version>0.1</version>\n        </dependency>\n        <!-- spring相关 -->\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-core</artifactId>\n            <version>${spring.version}</version>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-beans</artifactId>\n            <version>${spring.version}</version>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-context</artifactId>\n            <version>${spring.version}</version>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-jdbc</artifactId>\n            <version>${spring.version}</version>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-web</artifactId>\n            <version>${spring.version}</version>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-webmvc</artifactId>\n            <version>${spring.version}</version>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-aop</artifactId>\n            <version>${spring.version}</version>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-tx</artifactId>\n            <version>${spring.version}</version>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-orm</artifactId>\n            <version>${spring.version}</version>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-context-support</artifactId>\n            <version>${spring.version}</version>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-test</artifactId>\n            <version>${spring.version}</version>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-jms</artifactId>\n            <version>${spring.version}</version>\n        </dependency>\n        <dependency>\n            <groupId>org.aspectj</groupId>\n            <artifactId>aspectjrt</artifactId>\n            <version>1.6.11</version>\n        </dependency>\n        <dependency>\n            <groupId>org.aspectj</groupId>\n            <artifactId>aspectjweaver</artifactId>\n            <version>1.6.11</version>\n        </dependency>\n    </dependencies>\n</project>\n然后在com.marklux.dubbo.demo包中添加DemoService接口，代码如下：\npackage com.marklux.dubbo.demo;\n\n/**\n * Created by lumin on 18/5/15.\n */\npublic interface DemoService {\n    String sayHello(String name);\n}\n之后的服务提供方根据这个接口实现服务，消费者根据接口调用服务。（有点类似Thrift里的IDL文件）\n创建服务提供者\n创建一个新的maven模块msa-demo-provider，用于实现DemoService服务。模块结构如下：\n\n项目的pom.xml中需要添加对msa-demo-api模块的依赖：\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n\n    <groupId>com.marklux</groupId>\n    <artifactId>msa-demo-provider</artifactId>\n    <version>1.0-SNAPSHOT</version>\n    <dependencies>\n        <dependency>\n            <groupId>com.marklux</groupId>\n            <artifactId>msa-demo-api</artifactId>\n            <version>1.0-SNAPSHOT</version>\n        </dependency>\n    </dependencies>\n</project>\n首先编写DemoServiceImpl实现服务内容，代码如下：\npackage com.marklux.dubbo.demo.impl;\n\nimport com.marklux.dubbo.demo.DemoService;\nimport org.springframework.stereotype.Service;\n\n/**\n * Created by lumin on 18/5/15.\n */\n@Service(\"demoService\")\npublic class DemoServiceImpl implements DemoService {\n\n    public String sayHello(String name) {\n        return \"Hello, \" + name;\n    }\n}\n接下来填写msa-demo-provider.xml配置文件，配置服务接入注册中心，以及暴露端口号：\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:dubbo=\"http://code.alibabatech.com/schema/dubbo\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n    http://www.springframework.org/schema/beans/spring-beans.xsd\n    http://code.alibabatech.com/schema/dubbo\n    http://code.alibabatech.com/schema/dubbo/dubbo.xsd\">\n\n    <!-- 提供方应用信息，用于计算依赖关系 -->\n    <dubbo:application name=\"dubbo_provider\"  />\n\n    <!-- 使用zookeeper注册中心暴露服务地址 -->\n    <dubbo:registry address=\"zookeeper://127.0.0.1:2181\" />\n\n    <!-- 用dubbo协议在20880端口暴露服务 -->\n    <dubbo:protocol name=\"dubbo\" port=\"20880\" />\n\n    <!-- 声明需要暴露的服务接口 -->\n    <dubbo:service interface=\"com.marklux.dubbo.demo.DemoService\" ref=\"demoService\" />\n</beans>\n然后填写springmvc.xml，用于给入口类提供Spring服务容器的配置：\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:aop=\"http://www.springframework.org/schema/aop\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xmlns:util=\"http://www.springframework.org/schema/util\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/aop\n        http://www.springframework.org/schema/aop/spring-aop-4.0.xsd\n        http://www.springframework.org/schema/beans\n        http://www.springframework.org/schema/beans/spring-beans-4.0.xsd\n        http://www.springframework.org/schema/context\n        http://www.springframework.org/schema/context/spring-context-4.0.xsd\n        http://www.springframework.org/schema/util\n        http://www.springframework.org/schema/util/spring-util-4.0.xsd\"\n       default-autowire=\"byName\">\n\n    <aop:aspectj-autoproxy />\n    <context:component-scan base-package=\"com.marklux.dubbo.demo\" />\n    <import resource=\"classpath:msa-demo-provider.xml\" />\n</beans>\n最后在com.marklux.dubbo.demo.test包中添加测试启动类，用于启动服务：\npackage com.marklux.dubbo.demo.test;\n\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\n\nimport java.io.IOException;\n\n/**\n * Created by lumin on 18/5/15.\n */\npublic class DemoServiceImplTest  {\n    public static void main(String[] args) {\n        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\"classpath:spring-mvc.xml\");\n        context.start();\n        System.out.println(\"Dubbo Service started....\");\n        try {\n            System.in.read();   // 按任意键退出\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n启动DemoServiceImplTest类后服务就会注册并启动，这时候可以在dubbokeeper中看到服务的状态：\n\n创建消费者\n最后来创建一个调用服务的消费者，添加一个maven模块msa-demo-client，pom.xml同上，添加对msa-demo-api模块的依赖，注意并不需要msa-demo-provider的依赖。\n模块的结构如下：\n\n只有一个测试的启动类，代码如下：\npackage com.marklux.dubbo.demo.test;\n\nimport com.marklux.dubbo.demo.DemoService;\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\n\nimport java.io.IOException;\n\n/**\n * Created by lumin on 18/5/15.\n */\npublic class DemoServiceConsumerTest {\n\n    public static void main(String[] args) {\n        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(new String[]{\"classpath:springmvc.xml\"});\n\n        context.start();\n        DemoService demoService = (DemoService) context.getBean(\"demoService\");\n\n        System.out.println(demoService.sayHello(\"哈哈哈\"));\n        try {\n            System.in.read();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n    }\n}\n\n记得补充dubbo的配置文件msa-demo-client.xml和spring的配置文件springmvc.xml，如下：\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:dubbo=\"http://code.alibabatech.com/schema/dubbo\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        http://www.springframework.org/schema/beans/spring-beans.xsd\n        http://code.alibabatech.com/schema/dubbo\n        http://code.alibabatech.com/schema/dubbo/dubbo.xsd \">\n    <!-- 消费方应用名，用于计算依赖关系，不是匹配条件，不要与提供方一样 -->\n    <dubbo:application name=\"dubbo_consumer\" />\n    <!-- 使用multicast广播注册中心暴露发现服务地址 -->\n    <dubbo:registry  protocol=\"zookeeper\" address=\"zookeeper://127.0.0.1:2181\" />\n    <!-- 生成远程服务代理，可以和本地bean一样使用demoService -->\n    <dubbo:reference id=\"demoService\" interface=\"com.marklux.dubbo.demo.DemoService\" />\n</beans>\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:aop=\"http://www.springframework.org/schema/aop\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xmlns:util=\"http://www.springframework.org/schema/util\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/aop\n        http://www.springframework.org/schema/aop/spring-aop-4.0.xsd\n        http://www.springframework.org/schema/beans\n        http://www.springframework.org/schema/beans/spring-beans-4.0.xsd\n        http://www.springframework.org/schema/context\n        http://www.springframework.org/schema/context/spring-context-4.0.xsd\n        http://www.springframework.org/schema/util\n        http://www.springframework.org/schema/util/spring-util-4.0.xsd\"\n       default-autowire=\"byName\">\n\n    <aop:aspectj-autoproxy />\n    <context:component-scan base-package=\"com.marklux.dubbo.demo\" />\n    <import resource=\"classpath:msa-demo-consumer.xml\" />\n</beans>\n万事俱备，现在启动DemoServiceConsumerTest，可以看到成功调用了DemoService：\n\n在dubbokeeper中同样可以查看到其相关状态：\n\n小结\n至此，一个最简单的使用dubbo协议进行服务-调用的demo就完成了。可以看到最显著的特点是，在消费者中调用服务方提供的服务无需添加额外代码，整个调用过程完全透明。\n另外借助dubbokeeper这样的监控端，也更能够直观的理解整个应用服务的分布和运行情况。\n', null, null, null, '掘金', '83f1ddee-5b41-11e8-ac35-000c29753dbb');
INSERT INTO `nsnews` VALUES ('68574070-c8b7-424b-9d92-0d0815215134', 'Java效率工具之Swagger2', '现代化的研发组织架构中，一个研发团队基本包括了产品组、后端组、前端组、APP端研发、测试组、UI组等，各个细分组织人员各司其职，共同完成产品的全周期工作。如何进行组织架构内的有效高效沟通就显得尤其重要。其中，如何构建一份合理高效的接口文档更显重要。接口文档横贯各个端的研发人员，但是由于接口众多，细节不一，有时候理解起来并不是那么容易，引起‘内战’也在所难免， 并且维护也是一大难题。类似RAP文档管理系统，将接口文档进行在线维护，方便了前端和APP端人员查看进行对接开发，但是还是存在以下几点问题：文档是接口提供方手动导入的，是静态文档，没有提供接口测试功能；维护的难度不小。Swagger的出现可以完美解决以上传统接口管理方式存在的痛点。本文介绍Spring Boot整合Swagger2的流程，连带填坑。使用流程如下：1）引入相应的maven包：<dependency>\n  <groupId>io.springfox</groupId>\n  <artifactId>springfox-swagger2</artifactId>\n  <version>2.7.0</version>\n</dependency>\n\n<dependency>\n  <groupId>io.springfox</groupId>\n  <artifactId>springfox-swagger-ui</artifactId>\n  <version>2.7.0</version>\n</dependency>\n2）编写Swagger2的配置类：package com.trace.configuration;\n\nimport io.swagger.annotations.Api;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport springfox.documentation.builders.ApiInfoBuilder;\nimport springfox.documentation.builders.PathSelectors;\nimport springfox.documentation.builders.RequestHandlerSelectors;\nimport springfox.documentation.service.ApiInfo;\nimport springfox.documentation.spi.DocumentationType;\nimport springfox.documentation.spring.web.plugins.Docket;\nimport springfox.documentation.swagger2.annotations.EnableSwagger2;\n\n/**\n* Created by Trace on 2018-05-16.<br/>\n* Desc: swagger2配置类\n*/\n@SuppressWarnings({\"unused\"})\n@Configuration @EnableSwagger2\npublic class Swagger2Config {\n   @Value(\"${swagger2.enable}\") private boolean enable;\n\n   @Bean(\"UserApis\")\n   public Docket userApis() {\n       return new Docket(DocumentationType.SWAGGER_2)\n           .groupName(\"用户模块\")\n           .select()\n           .apis(RequestHandlerSelectors.withClassAnnotation(Api.class))\n           .paths(PathSelectors.regex(\"/user.*\"))\n           .build()\n           .apiInfo(apiInfo())\n           .enable(enable);\n   }\n\n   @Bean(\"CustomApis\")\n   public Docket customApis() {\n       return new Docket(DocumentationType.SWAGGER_2)\n           .groupName(\"客户模块\")\n           .select()\n           .apis(RequestHandlerSelectors.withClassAnnotation(Api.class))\n           .paths(PathSelectors.regex(\"/custom.*\"))\n           .build()\n           .apiInfo(apiInfo())\n           .enable(enable);\n   }\n\n   private ApiInfo apiInfo() {\n       return new ApiInfoBuilder()\n           .title(\"XXXXX系统平台接口文档\")\n           .description(\"提供子模块1/子模块2/子模块3的文档, 更多请关注公众号: 随行享阅\")\n           .termsOfServiceUrl(\"https://xingtian.github.io/trace.github.io/\")\n           .version(\"1.0\")\n           .build();\n   }\n}如上可见：通过注解@EnableSwagger2开启swagger2，apiInfo是接口文档的基本说明信息，包括标题、描述、服务网址、联系人、版本等信息；在Docket创建中，通过groupName进行分组，paths属性进行过滤，apis属性可以设置扫描包，或者通过注解的方式标识；通过enable属性，可以在application-{profile}.properties文件中设置相应值，主要用于控制生产环境不生成接口文档。3）controller层类和方法添加相关注解package com.trace.controller;\n\nimport com.trace.bind.ResultModel;\nimport com.trace.entity.po.Area;\nimport com.trace.entity.po.User;\nimport com.trace.service.UserService;\nimport io.swagger.annotations.Api;\nimport io.swagger.annotations.ApiImplicitParam;\nimport io.swagger.annotations.ApiImplicitParams;\nimport io.swagger.annotations.ApiOperation;\nimport org.springframework.web.bind.annotation.*;\nimport javax.annotation.Resource;\nimport java.util.List;\n\n/**\n * Created by Trace on 2017-12-01.<br/>\n * Desc: 用户管理controller\n */\n@SuppressWarnings(\"unused\")\n@RestController @RequestMapping(\"/user\")\n@Api(tags = \"用户管理\")\npublic class UserController {\n    @Resource private UserService userService;\n\n    @GetMapping(\"/query/{id}\")\n    @ApiOperation(\"通过ID查询\")\n    @ApiImplicitParam(name = \"id\", value = \"用户ID\", required = true, dataType = \"int\", paramType = \"path\")\n    public ResultModel<User> findById(@PathVariable int id) {\n        User user = userService.findById(id);\n        return ResultModel.success(\"id查询成功\", user);\n    }\n\n\n    @GetMapping(\"/query/ids\")\n    @ApiOperation(\"通过ID列表查询\")\n    public ResultModel<List<User>> findByIdIn(int[] ids) {\n        List<User> users = userService.findByIdIn(ids);\n        return ResultModel.success(\"in查询成功\", users);\n    }\n\n\n    @GetMapping(\"/query/user\")\n    @ApiOperation(\"通过用户实体查询\")\n    public ResultModel<List<User>> findByUser(User user) {\n        List<User> users = userService.findByUser(user);\n        return ResultModel.success(\"通过实体查询成功\", users);\n    }\n\n\n    @GetMapping(\"/query/all\")\n    @ApiOperation(\"查询所有用户\")\n    public ResultModel<List<User>> findAll() {\n        List<User> users = userService.findAll();\n        return ResultModel.success(\"全体查找成功\", users);\n    }\n\n\n    @GetMapping(\"/query/username\")\n    @ApiOperation(\"通过用户名称模糊查询\")\n    @ApiImplicitParam(name = \"userName\", value = \"用户名称\")\n    public ResultModel<List<User>> findByUserName(String userName) {\n        List<User> users = userService.findByUserName(userName);\n        return ResultModel.success(users);\n    }\n\n\n    @PostMapping(\"/insert\")\n    @ApiOperation(\"新增默认用户\")\n    public ResultModel<Integer> insert() {\n        User user = new User();\n        user.setUserName(\"zhongshiwen\");\n        user.setNickName(\"zsw\");\n        user.setRealName(\"钟仕文\");\n        user.setPassword(\"zsw123456\");\n        user.setGender(\"男\");\n        Area area = new Area();\n        area.setLevel((byte) 5);\n        user.setArea(area);\n        userService.save(user);\n        return ResultModel.success(\"新增用户成功\", user.getId());\n    }\n\n\n    @PutMapping(\"/update\")\n    @ApiOperation(\"更新用户信息\")\n    public ResultModel<Integer> update(User user) {\n        int row = userService.update(user);\n        return ResultModel.success(row);\n    }\n\n\n    @PutMapping(\"/update/status\")\n    @ApiOperation(\"更新单个用户状态\")\n    @ApiImplicitParams({\n            @ApiImplicitParam(name = \"id\", value = \"用户ID\", required = true),\n            @ApiImplicitParam(name = \"status\", value = \"状态\", required = true)\n    })\n    public ResultModel<User> updateStatus(int id, byte status) {\n        User user = userService.updateStatus(id, status);\n        return ResultModel.success(user);\n    }\n\n\n    @DeleteMapping(\"/delete\")\n    @ApiOperation(\"删除单个用户\")\n    @ApiImplicitParam(value = \"用户ID\", required = true)\n    public ResultModel<Integer> delete(int id) {\n        return ResultModel.success(userService.delete(id));\n    }\n}4）返回对象ResultModelpackage com.trace.bind;\n\nimport io.swagger.annotations.ApiModel;\nimport io.swagger.annotations.ApiModelProperty;\nimport lombok.Getter;\nimport lombok.Setter;\n\n/**\n* Created by Trace on 2017-12-01.<br/>\n* Desc:  接口返回结果对象\n*/\n@SuppressWarnings(\"unused\")\n@Getter @Setter @ApiModel(description = \"返回结果\")\npublic final class ResultModel<T> {\n    @ApiModelProperty(\"是否成功: true or false\")\n    private boolean result;\n    @ApiModelProperty(\"描述性原因\")\n    private String message;\n    @ApiModelProperty(\"业务数据\")\n    private T data;\n\n    private ResultModel(boolean result, String message, T data) {\n        this.result = result;\n        this.message = message;\n        this.data = data;\n    }\n\n    public static<T> ResultModel<T> success(T data) {\n        return new ResultModel<>(true, \"SUCCESS\", data);\n    }\n\n\n    public static<T> ResultModel<T> success(String message, T data) {\n        return new ResultModel<>(true, message, data);\n    }\n\n\n    public static ResultModel failure() {\n        return new ResultModel<>(false, \"FAILURE\", null);\n    }\n\n\n    public static ResultModel failure(String message) {\n        return new ResultModel<>(false, message, null);\n    }\n}\n5）ApiModel属性对象 -- User实体package com.trace.entity.po;\n\nimport com.trace.mapper.base.NotPersistent;\nimport io.swagger.annotations.ApiModel;\nimport io.swagger.annotations.ApiModelProperty;\nimport lombok.AllArgsConstructor;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\nimport java.time.LocalDate;\nimport java.time.LocalDateTime;\nimport java.util.List;\n\n/**\n * Created by Trace on 2017-12-01.<br/>\n * Desc: 用户表tb_user\n */\n@SuppressWarnings(\"unused\")\n@Data @NoArgsConstructor @AllArgsConstructor\n@ApiModel\npublic class User {\n    @ApiModelProperty(\"用户ID\") private Integer id;\n    @ApiModelProperty(\"账户名\") private String userName;\n    @ApiModelProperty(\"用户昵称\") private String nickName;\n    @ApiModelProperty(\"真实姓名\") private String realName;\n    @ApiModelProperty(\"身份证号码\") private String identityCard;\n    @ApiModelProperty(\"性别\") private String gender;\n    @ApiModelProperty(\"出生日期\") private LocalDate birth;\n    @ApiModelProperty(\"手机号码\") private String phone;\n    @ApiModelProperty(\"邮箱\") private String email;\n    @ApiModelProperty(\"密码\") private String password;\n    @ApiModelProperty(\"用户头像地址\") private String logo;\n    @ApiModelProperty(\"账户状态 0:正常; 1:冻结; 2:注销\") private Byte status;\n    @ApiModelProperty(\"个性签名\") private String summary;\n    @ApiModelProperty(\"用户所在区域码\") private String areaCode;\n    @ApiModelProperty(\"注册时间\") private LocalDateTime registerTime;\n    @ApiModelProperty(\"最近登录时间\") private LocalDateTime lastLoginTime;\n\n    @NotPersistent @ApiModelProperty(hidden = true)\n    private transient Area area; //用户所在地区\n\n    @NotPersistent @ApiModelProperty(hidden = true)\n    private transient List<Role> roles; //用户角色列表\n}\n简单说下Swagger2几个重要注解：@Api：用在请求的类上，表示对类的说明  tags \"说明该类的作用，可以在UI界面上看到的注解\" value \"该参数没什么意义，在UI界面上也看到，所以不需要配置\" @ApiOperation：用在请求的方法上，说明方法的用途、作用 value=\"说明方法的用途、作用\" notes=\"方法的备注说明\" @ApiImplicitParams：用在请求的方法上，表示一组参数说明 @ApiImplicitParam：用在@ApiImplicitParams注解中，指定一个请求参数的各个方面value：参数的汉字说明、解释 required：参数是否必须传 paramType：参数放在哪个地方 header --> 请求参数的获取：@RequestHeader query --> 请求参数的获取：@RequestParam path（用于restful接口）--> 请求参数的获取：@PathVariable body（不常用） form（不常用） dataType：参数类型，默认String，其它值dataType=\"Integer\" defaultValue：参数的默认值 @ApiResponses：用在请求的方法上，表示一组响应 @ApiResponse：用在@ApiResponses中，一般用于表达一个错误的响应信息 code：数字，例如400 message：信息，例如\"请求参数没填好\" response：抛出异常的类 @ApiModel：主要有两种用途：用于响应类上，表示一个返回响应数据的信息 入参实体：使用@RequestBody这样的场景，\n            请求参数无法使用@ApiImplicitParam注解进行描述的时候@ApiModelProperty：用在属性上，描述响应类的属性最终呈现结果：如前所述：通过maven导入了swagger-ui：<dependency>\n  <groupId>io.springfox</groupId>\n  <artifactId>springfox-swagger-ui</artifactId>\n  <version>2.7.0</version>\n</dependency>\n那么，启动应用后，会自动生成http://{root-path}/swagger-ui.html页面，访问后，效果如下所示：可以在线测试接口，如通过ID查询的接口/user/query/{id}全文完！', null, null, null, '掘金', '893ce2d0-5b41-11e8-ac35-000c29753dbb');
INSERT INTO `nsnews` VALUES ('7733b042-cb4d-47f1-8480-3b4b271fb7c0', 'SpringBoot开发案例从0到1构建分布式秒杀系统', '\n前言\n最近，被推送了不少秒杀架构的文章，忙里偷闲自己也总结了一下互联网平台秒杀架构设计，当然也借鉴了不少同学的思路。俗话说，脱离案例讲架构都是耍流氓，最终使用SpringBoot模拟实现了部分秒杀场景，同时跟大家分享交流一下。\n秒杀场景\n秒杀场景无非就是多个用户在同时抢购一件或者多件商品，专用词汇就是所谓的高并发。现实中经常被大家喜闻乐见的场景，一群大妈抢购打折鸡蛋的画面一定不会陌生，如此场面让服务员大姐很无奈，赶上不要钱了。\n\n业务特点\n\n瞬间高并发、电脑旁边的小哥哥、小姐姐们如超市哄抢的大妈一般，疯狂的点着鼠标\n库存少、便宜、稀缺限量，值得大家去抢购，如苹果肾，小米粉，锤子粉(理解万岁)\n\n用户规模\n用户规模可大可小，几百或者上千人的活动单体架构足以可以应付，简单的加锁、进程内队列就可以轻松搞定。一旦上升到百万、千万级别的规模就要考虑分布式集群来应对瞬时高并发。\n秒杀架构\n\n架构层级\n\n\n一般商家在做活动的时候，经常会遇到各种不怀好意的DDOS攻击(利用无辜的吃瓜群众夺取资源)，导致真正的我们无法获得服务！所以说高防IP还是很有必要的。\n\n\n搞活动就意味着人多，接入SLB，对多台云服务器进行流量分发，可以通过流量分发扩展应用系统对外的服务能力，通过消除单点故障提升应用系统的可用性。\n\n\n基于SLB价格以及灵活性考虑后面我们接入Nginx做限流分发，来保障后端服务的正常运行。\n\n\n后端秒杀业务逻辑，基于Redis 或者 Zookeeper 分布式锁，Kafka 或者 Redis 做消息队列，DRDS数据库中间件实现数据的读写分离。\n\n\n优化思路\n\n\n分流、分流、分流，重要的事情说三遍，再牛逼的机器也抵挡不住高级别的并发。\n\n\n限流、限流、限流，毕竟秒杀商品有限，防刷的前提下没有绝对的公平，根据每个服务的负载能力，设定流量极限。\n\n\n缓存、缓存、缓存、尽量不要让大量请求穿透到DB层，活动开始前商品信息可以推送至分布式缓存。\n\n\n异步、异步、异步，分析并识别出可以异步处理的逻辑，比如日志，缩短系统响应时间。\n\n\n主备、主备、主备，如果有条件做好主备容灾方案也是非常有必要的(参考某年锤子的活动被攻击)。\n\n\n最后，为了支撑更高的并发，追求更好的性能，可以对服务器的部署模型进行优化，部分请求走正常的秒杀流程，部分请求直接返回秒杀失败，缺点是开发部署时需要维护两套逻辑。\n\n\n分层优化\n\n前端优化：活动开始前生成静态商品页面推送缓存和CDN，静态文件(JS/CSS)请求推送至文件服务器和CDN。\n网络优化：如果是全国用户，最好是BGP多线机房，减少网络延迟。\n应用服务优化：Nginx最佳配置、Tomcat连接池优化、数据库配置优化、数据库连接池优化。\n\n全链路压测\n\n分析需压测业务场景涉及系统\n协调各个压测系统资源并搭建压测环境\n压测数据隔离以及监控(响应时间、吞吐量、错误率等数据以图表形式实时显示)\n压测结果统计(平均响应时间、平均吞吐量等数据以图表形式在测试结束后显示)\n优化单个系统性能、关联流程以及整个业务流程\n\n整个压测优化过程就是一个不断优化不断改进的过程，事先通过测试不断发现问题，优化系统，避免问题，指定应急方案，才能让系统的稳定性和性能都得到质的提升。\n代码案例\n可能秒杀架构原理大家都懂，网上也有不少实现方式，但大多都是文字的描述，告诉你如何如何，什么加锁、缓存、队列之类。但很少全面有的案例告诉你如何去做，既然是从0到1，希望以下代码案例可以帮助到你。当然最终落实到生产，还有很长的路要走，要根据自己的业务进行编码，实施并部署。\n你将会在代码案例中学到以下知识(不定期补充)：\n\n如何大家SpringBoot微服务\nThreadPoolExecutor线程池的使用\nReentrantLock和Synchronized的使用场景\n数据库锁机制(悲观锁、乐观锁)\n分布式锁(RedissLock、Zookeeper)\n进程内消息队列(LinkedBlockingQueue、ArrayBlockingQueue、ConcurrentLinkedQueue)\n分布式消息队列(Redis、Kafka)\n\n代码结构：\n├─src\n│  ├─main\n│  │  ├─java\n│  │  │  └─com\n│  │  │      └─itstyle\n│  │  │          └─seckill\n│  │  │              │  Application.java\n│  │  │              │  \n│  │  │              ├─common\n│  │  │              │  ├─api\n│  │  │              │  │      SwaggerConfig.java \n│  │  │              │  │      \n│  │  │              │  ├─config\n│  │  │              │  │      IndexController.java  \n│  │  │              │  │      \n│  │  │              │  ├─dynamicquery   \n│  │  │              │  │      DynamicQuery.java\n│  │  │              │  │      DynamicQueryImpl.java\n│  │  │              │  │      NativeQueryResultEntity.java\n│  │  │              │  │      \n│  │  │              │  ├─entity   \n│  │  │              │  │      Result.java\n│  │  │              │  │      Seckill.java\n│  │  │              │  │      SuccessKilled.java\n│  │  │              │  │      \n│  │  │              │  ├─enums\n│  │  │              │  │      SeckillStatEnum.java\n│  │  │              │  │      \n│  │  │              │  ├─interceptor\n│  │  │              │  │      MyAdapter.java\n│  │  │              │  │      \n│  │  │              │  └─redis\n│  │  │              │          RedisConfig.java\n│  │  │              │          RedisUtil.java\n│  │  │              │          \n│  │  │              ├─distributedlock\n│  │  │              │  ├─redis\n│  │  │              │  │      RedissLockDemo.java\n│  │  │              │  │      RedissLockUtil.java\n│  │  │              │  │      RedissonAutoConfiguration.java\n│  │  │              │  │      RedissonProperties.java\n│  │  │              │  │      \n│  │  │              │  └─zookeeper\n│  │  │              │          ZkLockUtil.java\n│  │  │              │          \n│  │  │              ├─queue\n│  │  │              │  ├─jvm\n│  │  │              │  │      SeckillQueue.java\n│  │  │              │  │      TaskRunner.java\n│  │  │              │  │      \n│  │  │              │  ├─kafka\n│  │  │              │  │      KafkaConsumer.java\n│  │  │              │  │      KafkaSender.java\n│  │  │              │  │      \n│  │  │              │  └─redis\n│  │  │              │          RedisConsumer.java\n│  │  │              │          RedisSender.java\n│  │  │              │          RedisSubListenerConfig.java\n│  │  │              │          \n│  │  │              ├─repository\n│  │  │              │      SeckillRepository.java\n│  │  │              │      \n│  │  │              ├─service\n│  │  │              │  │  ISeckillDistributedService.java\n│  │  │              │  │  ISeckillService.java\n│  │  │              │  │  \n│  │  │              │  └─impl\n│  │  │              │          SeckillDistributedServiceImpl.java\n│  │  │              │          SeckillServiceImpl.java\n│  │  │              │          \n│  │  │              └─web\n│  │  │                      SeckillController.java\n│  │  │                      SeckillDistributedController.java\n│  │  │                      \n│  │  ├─resources\n│  │  │  │  application.properties\n│  │  │  │  logback-spring.xml\n│  │  │  │  \n│  │  │  ├─sql\n│  │  │  │      seckill.sql\n│  │  │  │      \n│  │  │  ├─static\n│  │  │  └─templates\n│  │  └─webapp\n\n思考改进\n\n如何防止单个用户重复秒杀下单？\n如何防止恶意调用秒杀接口？\n如果用户秒杀成功，一直不支付该怎么办？\n消息队列处理完成后，如果异步通知给用户秒杀成功？\n如何保障 Redis、Zookeeper 、Kafka 服务的正常运行(高可用)？\n高并发下秒杀业务如何做到不影响其他业务(隔离性)？\n\n码云下载：从0到1构建分布式秒杀系统\n可供参考\nSpringBoot开发案例之整合Kafka实现消息队列\n', null, null, null, '掘金', '85960b52-5b41-11e8-ac35-000c29753dbb');
INSERT INTO `nsnews` VALUES ('77967888-88b6-49b5-81f4-a5e5b27272f0', 'Spring 数据处理框架的演变', '欢迎大家前往腾讯云+社区，获取更多腾讯海量技术实践干货哦~定量分析的成败在很大程度上取决于采集，存储和处理数据的能力。若能及时地向业务决策者提供深刻并可靠的数据解读，大数据项目就会有更多机会取得成功。如今，为数据处理设计合适的架构需要下很大工夫。数据处理主要包括 3 个方面：批处理：批量处理大量的静态数据。这一方式一般是分布式并且可扩展的。实时处理：实时处理主要处理连续且无尽的的数据流。这些数据流也是分布式的，且速度很快。混合计算模型：该模型是批处理和实时处理的结合，可以处理大量和高速数据。大数据项目的工程非常耗时，并且要利用合适的技能来解决数据采集和处理的问题，因为这些问题的解决对大多数方案来说都是必不可少的。Pivotal 曾推出了 Spring XD 和 Spring Cloud Dataflow 来减少大数据工程的开销。本文将简要介绍 Spring XD，以及该技术的最新版本，即 Spring Cloud Data Flow 的各方面细节。Spring XDSpring XD 是第一轮技术创新的产物。它为一些常见的与数据处理有关的任务提供了一种易用的解决方案。Spring XD 建立在了历经考验的 Spring 技术之上，并为数据摄入、移动、处理、深度分析、流处理和批处理提供了支持。Spring XD 为实时处理以及批处理提供了一个精巧、稳定，且可扩展的框架。用 Spring XD 来采集数据，并将数据从各种数据源移到目标会更加容易。Spring XD 架构在传统企业级 ETL（数据抽取、转换与加载的流程），实时分析和数据科学项目工作台的创建中得到了广泛应用。基于 Spring XD 的架构下图描述了基于 Spring XD 的架构。在下图这些模块的帮助下，我们可以创建、运行、部署并销毁数据管道，并对管道中的数据进行各种各样的处理。Spring XD 的主要组件是 Admin 和 Container。Admin UI 用于向服务器发送要执行某个任务的请求，然后服务器会调用关联的模块执行所请求的任务。在此，一个模块是构建 Spring 应用程序上下文的组件之一。所有模块都需要一个 XD 容器才能运行并执行该模块执行的相关任务。以下是 Spring XD 体系结构中的一些关键模块。数据源（Source）：一个数据流的创建总会从创建数据源模块开始。数据源可以使用轮询机制或事件驱动机制获得数据，然后只会提供数据的输出。数据处理器（Processor）：它会接收输入消息，并在经过某些类型的处理后产生输出消息。数据接收器（Sink）：顾名思义，该模块是一个数据流的终点。它会将输出的数据发送到一个外部的资源，例如 HDFS。作业（Job）：该模块会执行一些批处理作业。对 Spring Cloud Data Flow 的需求应用方面的需求总是在变化。这逐渐揭示了 Spring XD 的缺陷和对新一轮的技术创新的需求。以下是一些对新型框架最重要的需求：云技术在运营需求和非功能性需求的平台级实现方面发挥了巨大作用，但在应用级别上落实 非功能性要求仍是一个对工程量的挑战。在分布式环境中对特定阶段部署，动态资源分配，扩展能力和跟踪能力的需求也在日益增长。现在越来越多的平台意识到了将平台迁移到云服务供应商上，以及一个平台的可迁移性的必要性。基于微服务的云架构会更加适合这一需求，但 Spring XD 没有为基于微服务的架构提供直接的支持。Spring XD 支持大数据的应用场景，但仍有很大一部分项目不需要 Hadoop 来存储并处理数据。Spring Cloud Data Flow作为第二轮技术创新，Pivotal 推出了 Spring Cloud Data Flow 来替代原来的 Spring XD。Spring Cloud Data Flow 继承了 Spring XD 的优势，并通过利用云原生（cloud native）方法提供了更具可扩展性的解决方案。Spring Cloud Data Flow 是一个混合的计算模型，可以将流处理和批处理统一起来。开发人员可以利用 Spring Cloud Data Flow 来创建并操作数据管道来进行处理数据摄入、实时分析和批处理等常见流程。Spring Cloud Data Flow 只会提供一个管理服务模型，旨在精简数据项目的工程量，并让开发人员将精力集中在具体问题及对问题的分析上。Spring Cloud Data Flow 的架构从 Spring XD 到 Spring Cloud Data Flow，对功能的结构以及利用云原生架构扩展应用程序方法发生了从根本上的改变。Spring Cloud Data Flow 从传统的基于组件的架构转向了采用更适合云原生应用的，由消息驱动的微服务架构。现在 Spring XD 模块已经被部署在云端上的微服务取代了。具体地说，Spring Cloud Data Flow 在以下方面有着一些重大变化：为了利用云原生平台，Spring Cloud Data Flow 引入了服务提供者接口（SPI），该接口取代了 Spring XD 运行层（runtime layer）。像 Admin REST API，shell 和 UI 层这样的用户界面和集成元素与 Spring XD 相同，但底层架构已被大幅修改。服务提供者接口（SPI）取代了基于 Zookeeper 的运行模式。现在 SPI 会与其他系统（例如 Pivotal Cloud Foundry 或 Yarn）协调监测并启动基于微服务的应用程序。Spring Cloud Data Flow 的组件： 上图描绘了使用 Spring Cloud Data Flow 模型创建的一个典型数据流。作为 Spring Boot 微服务，数据源，作业，数据接收器和数据处理器都可以部署在 Cloud Foundry， Lattice 或 Yarn 集群上。通过使用部署在云原生平台上的这些微服务，我们可以创建数据管道并将其输入到 Yarn，Lattice 或基于 Cloud Foundry 的目标中。平台特定的 SPI（服务提供者接口）会被用于发现和绑定微服务，以及绑定基于开发平台的渠道（channel）。用例使用 Spring Cloud Data Flow 的真正好处是能够使用一个统一的框架来快速完成构建和配置工作，并建立数据摄入和处理流程，从而使开发人员能更好地关注具体问题。我们不妨构建这样一个用例来在高层面上见识一下 Spring Cloud Data Flow 的改变：在没有自带数据源模块的情况下构造一个完整的数据流，比如对 Facebook 的数据造一个数据流来分析 Facebook 的帖子。 在这种情况下，我们不能用在 Spring Cloud Data Flow 模块里能随便用的 Facebook 数据源模块，因此我们需要为 Facebook 数据源创建自定义模块。创建一个数据流需要三个主要的微服务：数据源，数据处理器和数据接收器。这三个微服务都有相应的接口类。Facebook 数据管道的数据源和数据接收器的微服务示例代码片段：Facebook 数据源：@SpringBootApplication\n@ComponentScan(.class)\npublic class SourceApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(SourceApplication.class, args);\n    }\n}\n\n@Configuration\n@EnableBinding(Source.class)\npublic class FBSource {\n    @Value(\"${format}\")\n    private String format;\n    \n    @Bean\n    @InboundChannelAdapter(value = Source.OUTPUT, poller = @Poller(fixedDelay = \"${fixedDelay}\", maxMessagesPerPoll = \"1\"))\n    public PostSource<String> FBPostSource() {\n        // 一些从 Facebook 获取帖子的逻辑\n        return // Facebook 帖子列表\n    }\n}@EnableBindings(Source.class)注解会检查相应的作为可绑定组件的接口类的实现是否存在（要在应用的 classpath 中设置，参考 Redis），然后这一组件会构建相应的渠道适配器（channel adapters）。所有微服务都会被转变为 Spring Boot 应用程序来实现更简单的依赖管理。Facebook 数据接收器：@SpringBootApplication\n@EnableBinding(Sink.class)\n@ComponentScan(.class)\npublic class SinkApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(SinkApplication.class, args);\n    }\n}\n\n@Configuration\npublic class FBSink {\n    private static Logger logger = LoggerFactory.getLogger(LogSink.class);\n    \n    @ServiceActivator(Source.INPUT)\n    public void loggerSink(Object payload) {\n        logger.info(\"Received: \" + payload);\n    }\n}上述代码会接收来自 Facebook 数据流的数据并将其写入控制台。Sink.class 在此会作为参数传递给 @EnableBinding 注解。另外 @ServiceActivator 会将数据输入模块连接到上例中的终端（endpoint）控制台。一些作为数据处理器的微服务将根据输入的 SPEL 表达式过滤来自 FBSource 微服务的 Facebook 帖子，而数据处理器微服务的输出就会是 FBSink 微服务的输入。结论Spring Cloud Data Flow 使用了 Spring Cloud stream 模块。我们可以用后者来创建和运行以 Spring Boot 应用为形式的消息传递微服务，以便它们可以部署在不同的平台上，独立运行并相互交互。在使用 Spring Cloud stream 模块创建数据管道时，Spring Cloud Data Flow 可以充当类似胶水的角色。目前有许多用于管理数据摄入，实时分析和数据加载的，独立的开源项目。Spring Cloud Data Flow 则为数据摄入，实时分析，批处理还有数据输出提供了一个统一的，可扩展的分布式服务。问答Spring Boot 如何配置端口？相关阅读Spring框架系列之AOP思想初识Spring Boot框架Spring 事务管理基础入门总结此文已由作者授权腾讯云+社区发布，原文链接：https://cloud.tencent.com/developer/article/1128177?fromSource=waitui', null, null, null, '掘金', '84d8f5d0-5b41-11e8-ac35-000c29753dbb');
INSERT INTO `nsnews` VALUES ('907eafb1-2cd6-477c-86b7-3246f1ec7980', 'Spring整合Quartz分布式调度', '\n    前言 为了保证应用的高可用和高并发性，一般都会部署多个节点；对于定时任务，如果每个节点都执行自己的定时任务，一方面耗费了系统资源，另一方面有些任务多次执行，可能引发应用逻辑问题，所以需要一个分布式的调度系统，来协调每个节点执行定时任务。\n    Spring整合Quartz Quartz是一个成熟的任务调度系统，Spring对Quartz做了兼容，方便开发，下面看看具体如何整合： 1.Maven依赖文件\n    <dependencies>\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-core</artifactId>\n            <version>4.3.5.RELEASE</version>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-context-support</artifactId>\n            <version>4.3.5.RELEASE</version>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-tx</artifactId>\n            <version>4.3.5.RELEASE</version>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-jdbc</artifactId>\n            <version>4.3.5.RELEASE</version>\n        </dependency>\n        <dependency>\n            <groupId>org.quartz-scheduler</groupId>\n            <artifactId>quartz</artifactId>\n            <version>2.2.3</version>\n        </dependency>\n        <dependency>\n            <groupId>mysql</groupId>\n            <artifactId>mysql-connector-java</artifactId>\n            <version>5.1.29</version>\n        </dependency>\n    </dependencies>\n    主要就是Spring相关库、quartz库以及mysql驱动库，注：分布式调度需要用到数据库，这里选用mysql；\n    2.配置job 提供了两种方式来配置job，分别是：MethodInvokingJobDetailFactoryBean和JobDetailFactoryBean 2.1MethodInvokingJobDetailFactoryBean 要调用特定bean的一个方法的时候使用，具体配置如下：\n    <bean id=\"firstTask\" class=\"org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean\">  \n    <property name=\"targetObject\" ref=\"firstService\" />  \n    <property name=\"targetMethod\" value=\"service\" />  \n</bea>\n    2.2JobDetailFactoryBean 这种方式更加灵活，可以设置传递参数，具体如下：\n    <bean id=\"firstTask\"\n        class=\"org.springframework.scheduling.quartz.JobDetailFactoryBean\">\n        <property name=\"jobClass\" value=\"zh.maven.SQuartz.task.FirstTask\" />\n        <property name=\"jobDataMap\">\n            <map>\n                <entry key=\"firstService\" value-ref=\"firstService\" />\n            </map>\n        </property>\n</bean>\n    jobClass定义的任务类，继承QuartzJobBean，实现executeInternal方法；jobDataMap用来给job传递数据;\n    3.配置调度使用的触发器 同样提供了两种触发器类型：SimpleTriggerFactoryBean和CronTriggerFactoryBean 重点看CronTriggerFactoryBean，这种类型更加灵活，具体如下：\n    <bean id=\"firstCronTrigger\"\n    class=\"org.springframework.scheduling.quartz.CronTriggerFactoryBean\">\n    <property name=\"jobDetail\" ref=\"firstTask\" />\n    <property name=\"cronExpression\" value=\"0/5 * * ? * *\" />\n</bean>\n    jobDetail指定的就是在步骤2中配置的job，cronExpression配置了每5秒执行一次job；\n    4.配置Quartz调度器的SchedulerFactoryBean 同样提供了两种方式：内存RAMJobStore和数据库方式 4.1内存RAMJobStore job的相关信息存储在内存里，每个节点存储各自的，互相隔离，配置如下：\n    <bean class=\"org.springframework.scheduling.quartz.SchedulerFactoryBean\">\n    <property name=\"triggers\">\n        <list>\n            <ref bean=\"firstCronTrigger\" />\n        </list>\n    </property>\n</bean>\n    4.2数据库方式 job的相关信息存储在数据库中，所有节点共用数据库，每个节点通过数据库来通信，保证一个job同一时间只会在一个节点上执行，并且 如果某个节点挂掉，job会被分配到其他节点执行，具体配置如下：\n    <bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"\n        destroy-method=\"close\">\n        <property name=\"driverClass\" value=\"com.mysql.jdbc.Driver\" />\n        <property name=\"jdbcUrl\" value=\"jdbc:mysql://localhost:3306/quartz\" />\n        <property name=\"user\" value=\"root\" />\n        <property name=\"password\" value=\"root\" />\n    </bean>\n    <bean class=\"org.springframework.scheduling.quartz.SchedulerFactoryBean\">\n        <property name=\"dataSource\" ref=\"dataSource\" />\n        <property name=\"configLocation\" value=\"classpath:quartz.properties\" />\n        <property name=\"triggers\">\n            <list>\n                <ref bean=\"firstCronTrigger\" />\n            </list>\n        </property>\n    </bean>\n    dataSource用来配置数据源，数据表相关信息，可以到官网下载gz包，sql文件在路径：docsdbTables下，里面提供了主流数据库的sql文件，总共11张表； configLocation配置的quartz.properties文件在quartz.jar的org.quartz包下，里面提供了一些默认的数据，比如org.quartz.jobStore.class\n    org.quartz.jobStore.class: org.quartz.simpl.RAMJobStore\n    这里需要将quartz.properties拷贝出来做一些修改，具体修改如下：\n    org.quartz.scheduler.instanceId: AUTO\norg.quartz.jobStore.class: org.quartz.impl.jdbcjobstore.JobStoreTX\norg.quartz.jobStore.isClustered: true\norg.quartz.jobStore.clusterCheckinInterval: 1000\n    5.相关类\n    public class FirstTask extends QuartzJobBean {\n \n    private FirstService firstService;\n \n    @Override\n    protected void executeInternal(JobExecutionContext context) throws JobExecutionException {\n        firstService.service();\n    }\n \n    public void setFirstService(FirstService firstService) {\n        this.firstService = firstService;\n    }\n}\n    FirstTask继承QuartzJobBean，实现executeInternal方法，调用FirstService;\n    public class FirstService implements Serializable {\n \n    private static final long serialVersionUID = 1L;\n \n    public void service() {\n        System.out.println(new SimpleDateFormat(\"YYYYMMdd HH:mm:ss\").format(new Date()) + \"---start FirstService\");\n        try {\n            Thread.sleep(2000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(new SimpleDateFormat(\"YYYYMMdd HH:mm:ss\").format(new Date()) + \"---end FirstService\");\n    }\n}\n    FirstService需要提供序列化接口，因为需要保存在数据库中；\n    public class App {\n    public static void main(String[] args) {\n        AbstractApplicationContext context = new ClassPathXmlApplicationContext(\"quartz.xml\");\n    }\n}\n    主类用来加载quartz配置文件；\n    测试分布式调度 1.同时启动App两次，观察日志：\n    20180405 14:48:10---start FirstService\n20180405 14:48:12---end FirstService\n20180405 14:48:15---start FirstService\n20180405 14:48:17---end FirstService\n    其中A1有日志输出，A2没有；当停掉A1以后，A2有日志输出；\n    2.添加新的job分别新建：SecondTask和SecondService，同时添加相关配置文件，启动App观察日志： A1日志如下：\n    20180405 15:03:15---start FirstService\n20180405 15:03:15---start SecondService\n20180405 15:03:17---end FirstService\n20180405 15:03:17---end SecondService\n20180405 15:03:20---start FirstService\n20180405 15:03:22---end FirstService\n20180405 15:03:25---start FirstService\n20180405 15:03:27---end FirstService\n    A2日志如下：\n    20180405 15:03:20---start SecondService\n20180405 15:03:22---end SecondService\n20180405 15:03:25---start SecondService\n20180405 15:03:27---end SecondService\n    可以发现A1和A2都有执行任务，但是同一任务同一时间只会在一个节点执行，并且只有在执行结束后才有可能分配到其他节点；\n    3.如果间隔时间小于任务执行时间，比如这里改成sleep(6000) A1日志如下：\n    20180405 15:14:40---start FirstService\n20180405 15:14:45---start FirstService\n20180405 15:14:46---end FirstService\n20180405 15:14:50---start FirstService\n20180405 15:14:50---start SecondService\n20180405 15:14:51---end FirstService\n    A2日志如下：\n    20180405 15:14:40---start SecondService\n20180405 15:14:45---start SecondService\n20180405 15:14:46---end SecondService\n20180405 15:14:51---end SecondService\n    间隔时间是5秒，而任务执行需要6秒，观察日志可以发现，任务还没有结束，新的任务已经开始，这种情况可能引发应用的逻辑问题，其实就是任务能不能支持串行的问题；\n    4.@DisallowConcurrentExecution注解保证任务的串行 在FirstTask和SecondTask上分别添加@DisallowConcurrentExecution注解，日志结果如下： A1日志如下：\n    20180405 15:32:45---start FirstService\n20180405 15:32:51---end FirstService\n20180405 15:32:51---start FirstService\n20180405 15:32:51---start SecondService\n20180405 15:32:57---end FirstService\n20180405 15:32:57---end SecondService\n20180405 15:32:57---start FirstService\n20180405 15:32:57---start SecondService\n    A2日志如下：\n    20180405 15:32:45---start SecondService\n20180405 15:32:51---end SecondService\n    观察日志可以发现，任务只有在end以后，才会开始新的任务，实现了任务的串行化；\n    总结 本文旨在对Spring+Quartz分布式调度有一个直观的了解，通过实际的使用来解决问题，当然可能还有很多疑问比如它是如何调度的，数据库如果挂了会怎么样等等，还需要做更加深入的了解。\n', null, null, null, '掘金', '8469c2dc-5b41-11e8-ac35-000c29753dbb');
INSERT INTO `nsnews` VALUES ('978aeb93-397c-461c-a177-fc94d818811f', '谈优化：池相关内容', '\n    \n    缘起\n    之前发过三篇fastdfs相关内容：FastDFS 集群 安装 配置、 分布式文件系统FastDFS详解、\n        一次FastDFS并发问题的排查经历，今天在看fastdfs的java 客户端代码发现如下：\n    \n        \n    \n    \n        \n    \n    如果每次都类似：\n    trackerServer = trackerClient.getConnection();\n    我们经常提到线程池，数据库连接池，那么这个地方是否也应该用一种池的做法呢？\n    数据库连接池、线程池\n    数据库连接池、线程池那么的相似但是又不一样，让我想起来几周前和VIVO峰交流过这个问题。\n    下面是交流的大概结论：\n    \n        数据库连接池和线程池不一样的,表面上似乎一样:线程池是线程的池子，数据库连接池是数据库连接的池子（好像是废话，哈哈），但是呢，线程池的线程不会跑出池子，数据库连接池的连接会跑出去，这使得他们内部的实现差异很大，数据库连接池就是应用程序会从连接池中，把连接拿走，close的时候，再还回数据库连接池，连接池要维护连接的可用性，最大连接数，还会有最大获取连接的等待时间，那么问题来了 数据库连接池 应该配置多少毕竟合适（这又是另外一个话题了），如果达到了最大连接数，并且连接池的连接全部被拿走了，这个时候再获取连接，需要等待，超时就会抛异常了。\n    \n    不错的一篇线程池文章：深入分析java线程池的实现原理。\n    说到这里，我们应该对数据库连接池、线程池有个大概的了解了，从这里看我们上面的socket这个特性与数据库连接更像，下面我们谈谈怎么来实现。\n    池的实现\n    既然是池那么是否有一个容器进行存放这个资源，还必须要提供从容器取资源，和归还资源到容器的操作。\n    在Java中这个容器让我想到了：集合（线性的、链式的）、Map、队列、数组等等。\n    简单思路：\n    那么不管用那种容器都是可以存数据了（有时候需要注意并发），那么取就是 把容器里面内容取一个并且在容器里面移除，那么还就是把 拿走的在插入到容器中即可。\n    我们再想想连接池还有那些：\n    最大、最小个数、初始大小、空闲时间、获取不到的时候需要等多久或者一直等待 等等操作。\n    \n        大家是倾向自己实现呢？ 还是使用现成的呢 ？\n    \n    期待留言区你的回答以及大概思路……\n    \n        类似http连接也是属于珍贵资源，我们也是需要使用池的，很多资源都是非常稀缺的，如果被无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，合理的用池把这些资源进行管理通常也是优化的一个重要手段。\n    \n    \n    如果读完觉得有收获的话，欢迎点赞、关注、加公众号【匠心零度】，查阅更多精彩历史！！！\n    加入知识星球，一起探讨！\n    \n', null, null, null, '掘金', '8a72541e-5b41-11e8-ac35-000c29753dbb');
INSERT INTO `nsnews` VALUES ('9c96d888-009f-4341-b102-a30f53c0916e', '关于Java IO与NIO知识都在这里', '由于内容比较多，我下面放的一部分是我更新在我的微信公众号上的链接，微信排版比较好看，更加利于阅读。每一篇文章下面我都把文章的主要内容给列出来了，便于大家学习与回顾。\nJava面试通关手册（Java学习指南） Github地址：github.com/Snailclimb/…\n\nIO流学习总结\n\n一 Java IO，硬骨头也能变软\n主要内容：\n（1） 按操作方式分类结构图：\n\n（2）按操作对象分类结构图\n\n二 java IO体系的学习总结\n\n\nIO流的分类：\n\n按照流的流向分，可以分为输入流和输出流；\n按照操作单元划分，可以划分为字节流和字符流；\n按照流的角色划分为节点流和处理流。\n\n\n\n流的原理浅析:\njava Io流共涉及40多个类，这些类看上去很杂乱，但实际上很有规则，而且彼此之间存在非常紧密的联系， Java Io流的40多个类都是从如下4个抽象类基类中派生出来的。\n\nInputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。\nOutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。\n\n\n\n常用的io流的用法\n\n\n三 Java IO面试题\n\nNIO学习总结\n\n一 Java NIO 概览\n主要内容:\n\n\nNIO简介:\nJava NIO 是 java 1.4, 之后新出的一套IO接口NIO中的N可以理解为Non-blocking，不单纯是New。\n\n\nNIO的特性/NIO与IO区别:\n\n1)IO是面向流的，NIO是面向缓冲区的；\n2)IO流是阻塞的，NIO流是不阻塞的;\n3)NIO有选择器，而IO没有。\n\n\n\n读数据和写数据方式:\n\n\n从通道进行数据读取 ：创建一个缓冲区，然后请求通道读取数据。\n\n\n从通道进行数据写入 ：创建一个缓冲区，填充数据，并要求通道写入数据。\n\n\n\n\nNIO核心组件简单介绍\n\nChannels\nBuffers\nSelectors\n\n\n\n二 Java NIO 之 Buffer(缓冲区)\n主要内容:\n\n\nBuffer(缓冲区)介绍:\n\nJava NIO Buffers用于和NIO Channel交互。 我们从Channel中读取数据到buffers里，从Buffer把数据写入到Channels；\nBuffer本质上就是一块内存区；\n一个Buffer有三个属性是必须掌握的，分别是：capacity容量、position位置、limit限制。\n\n\n\nBuffer的常见方法\n\nBuffer clear()\nBuffer flip()\nBuffer rewind()\nBuffer position(int newPosition)\n\n\n\nBuffer的使用方式/方法介绍:\n\n分配缓冲区（Allocating a Buffer）:\n\nByteBuffer buf = ByteBuffer.allocate(28);//以ByteBuffer为例子\n\n写入数据到缓冲区（Writing Data to a Buffer）\n\n写数据到Buffer有两种方法：\n1.从Channel中写数据到Buffer\nint bytesRead = inChannel.read(buf); //read into buffer.\n2.通过put写数据：\nbuf.put(127);\n\n\nBuffer常用方法测试\n说实话，NIO编程真的难，通过后面这个测试例子，你可能才能勉强理解前面说的Buffer方法的作用。\n\n\n三 Java NIO 之 Channel（通道）\n主要内容:\n\nChannel（通道）介绍\n\n通常来说NIO中的所有IO都是从 Channel（通道） 开始的。\nNIO Channel通道和流的区别：\n\n\nFileChannel的使用\nSocketChannel和ServerSocketChannel的使用\n️DatagramChannel的使用\nScatter / Gather\n\nScatter: 从一个Channel读取的信息分散到N个缓冲区中(Buufer).\nGather: 将N个Buffer里面内容按照顺序发送到一个Channel.\n\n\n通道之间的数据传输\n\n在Java NIO中如果一个channel是FileChannel类型的，那么他可以直接把数据传输到另一个channel。\ntransferFrom() :transferFrom方法把数据从通道源传输到FileChannel\ntransferTo() :transferTo方法把FileChannel数据传输到另一个channel\n\n\n\n四 Java NIO之Selector（选择器）\n主要内容:\n\n\nSelector（选择器）介绍\n\nSelector 一般称 为选择器 ，当然你也可以翻译为 多路复用器 。它是Java NIO核心组件中的一个，用于检查一个或多个NIO Channel（通道）的状态是否处于可读、可写。如此可以实现单线程管理多个channels,也就是可以管理多个网络链接。\n使用Selector的好处在于： 使用更少的线程来就可以来处理通道了， 相比使用多个线程，避免了线程上下文切换带来的开销。\n\n\n\nSelector（选择器）的使用方法介绍\n\nSelector的创建\n\nSelector selector = Selector.open();\n\n注册Channel到Selector(Channel必须是非阻塞的)\n\nchannel.configureBlocking(false);\nSelectionKey key = channel.register(selector, Selectionkey.OP_READ);\n\n\nSelectionKey介绍\n一个SelectionKey键表示了一个特定的通道对象和一个特定的选择器对象之间的注册关系。\n\n\n从Selector中选择channel(Selecting Channels via a Selector)\n选择器维护注册过的通道的集合，并且这种注册关系都被封装在SelectionKey当中.\n\n\n停止选择的方法\nwakeup()方法 和close()方法。\n\n\n\n\n模板代码\n有了模板代码我们在编写程序时，大多数时间都是在模板代码中添加相应的业务代码。\n\n\n客户端与服务端简单交互实例\n\n\n五 Java NIO之拥抱Path和Files\n主要内容\n一 文件I/O基石：Path：\n\n创建一个Path\nFile和Path之间的转换，File和URI之间的转换\n获取Path的相关信息\n移除Path中的冗余项\n\n二 拥抱Files类：\n\nFiles.exists() 检测文件路径是否存在\nFiles.createFile() 创建文件\nFiles.createDirectories()和Files.createDirectory()创建文件夹\nFiles.delete()方法 可以删除一个文件或目录\nFiles.copy()方法可以吧一个文件从一个地址复制到另一个位置\n获取文件属性\n遍历一个文件夹\nFiles.walkFileTree()遍历整个目录\n\n欢迎关注我的微信公众号:\"Java面试通关手册\"（一个有温度的微信公众号，期待与你共同进步~~~坚持原创，分享美文，分享各种Java学习资源）：\n\n', null, null, null, '掘金', '813222c6-5b41-11e8-ac35-000c29753dbb');
INSERT INTO `nsnews` VALUES ('9f51e4ef-a5b7-4c98-93d4-01325b76491c', '并发编程 —— 自己写一个异步回调 API', '1. 前言\n在并发编程中，异步回调的效率不言而喻，在业务开发中，如果由阻塞的任务需要执行，必然要使用异步线程。并且，如果我们想在异步执行之后，根据他的结果执行一些动作。\nJDK 8 之前的 Future 只能解决上面需求的一半问题，即异步执行，返回一个 Future，需要程序员调用 get 方法等待，或者使用 isDone 轮询。\n效率不高。\nJDK 8 新出的 CompletableFuture API 可以解决这个问题。但他的 API， 说实话，不太好用。\n我们只想要一个简单的 API，能实现我们的回调功能。\n我需要 3 个功能：\n\n能通过 get 之类的方法返回结果。\n能设置监听器进行回调。\n可以在业务线程中设置成功或者失败。\n\n楼主写一个简单的例子，借鉴了 Netty 的异步 API，希望能起到抛砖引玉的作用。\n2. 设计\n根据我们的需求：\n第一，我们需要一个类，拥有 get 方法和 addListener 方法。\n第二，我们需要一个类，能够回调我们设置的监听器。\n第三，我们需要一个类，能够在业务线程中设置成功或者失败。\n3. 初步实现\n设计一个监听器接口：\n/**\n * 监听器\n * @author stateis0 \n */\npublic interface MyListener {\n  /**\n   * 子类需要重写此方法，在异步任务完成之后会回调此方法。\n   * @param promise 异步结果占位符。\n   */\n  void operationComplete(MyPromise promise);\n}\n设计一个异步占位符，类似 Future：\n/**\n * 异步执行结果占位符\n *\n * @author stateis0\n */\npublic class MyPromise {\n\n  /** 监听器集合*/\n  List<MyListener> listeners = new ArrayList<MyListener>();\n\n  /** 是否成功*/\n  boolean success;\n\n  /** 执行结果**/\n  Object result;\n\n  /** 设置事变计数器**/\n  int failCount;\n\n  /**\n   * 设置成功，并通知所有监听器。\n   * @param result 结果\n   * @return 是否成功\n   */\n  public boolean setSuccess(Object result) {\n    if (success) {\n      return false;\n    }\n\n    success = true;\n    this.result = result;\n\n    signalListeners();\n    return true;\n  }\n\n  /**\n   * 通知所有监听器，回调监听器方法。\n   */\n  private void signalListeners() {\n    for (MyListener l : listeners) {\n      l.operationComplete(this);\n    }\n  }\n\n  /**\n   * 设置失败\n   * @param e 异常对象\n   * @return 设置是否成功\n   */\n  public boolean setFail(Exception e) {\n    if (failCount > 0) {\n      return false;\n    }\n    ++failCount;\n    result = e;\n    signalListeners();\n    return true;\n  }\n\n  /**\n   * 是否成功执行\n   */\n  public boolean isSuccess() {\n    return success;\n  }\n\n  /**\n   * 添加监听器\n   * @param myListener 监听器\n   */\n  public void addListener(MyListener myListener) {\n    listeners.add(myListener);\n  }\n\n  /**\n   * 删除监听器\n   * @param myListener 监听器\n   */\n  public void removeListener(MyListener myListener) {\n    listeners.remove(myListener);\n  }\n\n  /**\n   * 获取执行结果\n   */\n  public Object get() {\n    return result;\n  }\n}\n我们希望使用线程池执行此类任务，所以需要一个自定义的 Runnable，而在这个 Runnable 中，我们需要做一些简单的手脚：\n/**\n * 一个任务类，通过重写 doWork 方法执行任务\n * @param <V> 返回值类型\n * @author stateis0 \n */\npublic abstract class MyRunnable<V> implements Runnable {\n\n  final MyPromise myPromise;\n\n  protected MyRunnable(MyPromise myPromise) {\n    this.myPromise = myPromise;\n  }\n\n  @Override\n  public void run() {\n    try {\n      V v = doWork();\n      myPromise.setSuccess(v);\n    } catch (Exception e) {\n      myPromise.setFail(e);\n    }\n  }\n\n  /**\n   * 子类需要重写此方法。并返回值，这个值由 Promise 的 get 方法返回。\n   */\n  public abstract V doWork();\n}\n4. 写个 Demo 测试一下\n/**\n * @author stateis0\n */\npublic class MyDemo {\n\n  public static void main(String[] args) {\n\n    // 占位对象\n    final MyPromise myPromise = new MyPromise();\n\n    final Dto dto = new Dto();\n\n    // 线程池\n    Executor executor = Executors.newFixedThreadPool(1);\n\n    // 异步执行任务，\n    executor.execute(new MyRunnable<String>(myPromise) {\n      @Override\n      public String doWork() {\n        return dto.doSomething();\n      }\n    });\n\n    // 添加一个监听器\n    myPromise.addListener(new MyListener() {\n      // 当任务完成后，就执行此方法。\n      @Override\n      public void operationComplete(MyPromise promise) {\n        // 获取结果\n        String result;\n        // 如果任务成功执行了\n        if (promise.isSuccess()) {\n          // 获取结果并打印\n          result = (String) promise.get();\n          System.out.println(\"operationComplete ----> \" + result);\n        }\n        // 如果失败了, 打印异常堆栈\n        else {\n          ((Exception) promise.get()).printStackTrace();\n        }\n      }\n    });\n  }\n\n}\n\nclass Dto {\n\n  public String doSomething() {\n    System.out.println(\"doSomething\");\n//    throw new RuntimeException(\"cxs\");\n    return \"result is success\";\n  }\n}\n执行结果：\ndoSomething\noperationComplete ----> result is success\n符合我们的预期。我们希望在业务对象 Dto 的 doSomething 成功返回之后，回调监听器的  operationComplete 方法。如果失败，打印异常堆栈。\n当然，整体代码比较简单，仅仅只是抛砖引玉。\n实际上，如果直接向 Callable 或者 Runnable 传入一个业务对象，当 call 方法或者 run 方法执行完毕，就可以根据执行结果执行我们的业务对象的方法了。这样就是一个最简单直接的异步回调。\n只是这样过于耦合。\n异步任务和业务的任务耦合在了一起，并且不能添加多个监听器，也无法使用  promise 的 setSuccess 功能和 setFail 功能，这两个功能可以在业务线程中设置成功或者失败，灵活性更高。\n关于异步，我们可以多看看 Netty 的 API 设计，易懂好用。\n', null, null, null, '掘金', '861c7516-5b41-11e8-ac35-000c29753dbb');
INSERT INTO `nsnews` VALUES ('e96c5958-9d87-470c-b0b5-ef2e650f052c', 'Java9后String的空间优化', '前言\n据我所知 Java 开发人员几乎任何时候都会想到 String，字符串确实已经成为最常用的类了，而且是大量使用。我们都知道，String 其实是封装了字符，里面必须由字符或字节数组来存放，从 Java9 开始 Java 语言开发者对 String 做了一些空间的优化。\n从char到byte\nJDK9 之前的库的 String 类的实现使用了 char 数组来存放字符串，char 占用16位，即两字节。\nprivate final char value[];\n这种情况下，如果我们要存储字符A，则为0x00 0x41，此时前面的一个字节空间浪费了。但如果保存中文字符则不存在浪费的情况，也就是说如果保存 ISO-8859-1 编码内的字符则浪费，之外的字符则不会浪费。\n而 JDK9 后 String 类的实现使用了 byte 数组存放字符串，每个 byte 占用8位，即1字节。\nprivate final byte[] value\n编码\nString 支持多种编码，但如果不指定编码的话，它可能使用两种编码，分别为 LATIN1 和 UTF16。LATIN1 可能比较陌生，其实就是 ISO-8859-1 编码，属于单字节编码。而 UTF16 为双字节编码，它使用1个或2个16位长的空间存储。\n压缩空间\n压缩的字符对象主要是在 ISO-8859-1 编码内的字符，比如英语字母数字还有其他常见符号。为了更好理解我们看下图，假如我们有一个“what”字符串，那么如果在 Java9 之前，它的存储是按如下队列排列的，可以看到每个字符都需要16位来存储，而高字节位都为0，这个其实就是浪费了。\n\n而在 Java9 后，它的存储的排列则很紧凑了，如下图，只需四个字节即可。\n\n但如果是“哈a”，则布局为下图，所以如果字符串中的字符一旦包含了不在 ISO-8859-1 编码内的字符，则同样还是统一使用16位长度来保存。\n\nJava9 的 String 默认是使用了上述紧凑的空间布局的，看如下代码，默认将 COMPACT_STRINGS 设置为 true。而如果要取消紧凑的布局可以通过配置 VM 参数-XX:-CompactStrings实现。\nstatic final boolean COMPACT_STRINGS;\nstatic {\n    COMPACT_STRINGS = true;\n}\n字符串长度\n因为改变了 String 的实现，使用了 UTF-16 或 LATIN-1 编码，所以内部需要一个标识coder来表示使用了哪种编码，LATIN1 值为0，UTF16 值为1。\nprivate final byte coder;\nstatic final byte LATIN1 = 0;\nstatic final byte UTF16  = 1;\n而字符串的长度也与编码相关，计算时通过右移来实现。如果是 LATIN-1 编码，则右移0位，数组长度即为字符串长度。而如果是 UTF16 编码，则右移1位，数组长度的二分之一为字符串长度。\npublic int length() {\n    return value.length >> coder();\n}\n总结\n字符串对象是 Java 中大量使用的对象，而且我们会轻易大量使用它而从不考虑它的代价，所以对其的空间优化是有必要的，Java9 开始对 这能帮助我们减少字符串在堆中占用的空间，而且还能减轻GC压力。同时也能看到该空间优化对中文来说意义不大。\n-------------推荐阅读------------\n我的2017文章汇总——机器学习篇\n我的2017文章汇总——Java及中间件\n我的2017文章汇总——深度学习篇\n我的2017文章汇总——JDK源码篇\n我的2017文章汇总——自然语言处理篇\n我的2017文章汇总——Java并发篇\n\n跟我交流，向我提问：\n\n公众号的菜单已分为“读书总结”、“分布式”、“机器学习”、“深度学习”、“NLP”、“Java深度”、“Java并发核心”、“JDK源码”、“Tomcat内核”等，可能有一款适合你的胃口。\n为什么写《Tomcat内核设计剖析》\n欢迎关注：\n\n', null, null, null, '掘金', '8371ec06-5b41-11e8-ac35-000c29753dbb');
INSERT INTO `nsnews` VALUES ('fa445205-c92c-4d20-93ec-e9022966ebc6', '一篇文章，让你彻底弄懂生产者--消费者问题', '生产者-消费者模式是一个十分经典的多线程并发协作的模式，弄懂生产者-消费者问题能够让我们对并发编程的理解加深。所谓生产者-消费者问题，实际上主要是包含了两类线程，一种是生产者线程用于生产数据，另一种是消费者线程用于消费数据，为了解耦生产者和消费者的关系，通常会采用共享的数据区域，就像是一个仓库，生产者生产数据之后直接放置在共享数据区中，并不需要关心消费者的行为；而消费者只需要从共享数据区中去获取数据，就不再需要关心生产者的行为。但是，这个共享数据区域中应该具备这样的线程间并发协作的功能：\n\n如果共享数据区已满的话，阻塞生产者继续生产数据放置入内；\n如果共享数据区为空的话，阻塞消费者继续消费数据；\n\n在实现生产者消费者问题时，可以采用三种方式：\n1.使用Object的wait/notify的消息通知机制；\n2.使用Lock的Condition的await/signal的消息通知机制；\n3.使用BlockingQueue实现。本文主要将这三种实现方式进行总结归纳。\n1. wait/notify的消息通知机制\n1.1 预备知识\nJava 中，可以通过配合调用 Object 对象的 wait() 方法和 notify()方法或 notifyAll() 方法来实现线程间的通信。在线程中调用 wait() 方法，将阻塞当前线程，直至等到其他线程调用了调用 notify() 方法或 notifyAll() 方法进行通知之后，当前线程才能从wait()方法出返回，继续执行下面的操作。\n\n\nwait\n该方法用来将当前线程置入休眠状态，直到接到通知或被中断为止。在调用 wait()之前，线程必须要获得该对象的对象监视器锁，即只能在同步方法或同步块中调用 wait()方法。调用wait()方法之后，当前线程会释放锁。如果调用wait()方法时，线程并未获取到锁的话，则会抛出IllegalMonitorStateException异常，这是以个RuntimeException。如果再次获取到锁的话，当前线程才能从wait()方法处成功返回。\n\n\nnotify\n该方法也要在同步方法或同步块中调用，即在调用前，线程也必须要获得该对象的对象级别锁，如果调用 notify()时没有持有适当的锁，也会抛出 IllegalMonitorStateException。\n该方法任意从WAITTING状态的线程中挑选一个进行通知，使得调用wait()方法的线程从等待队列移入到同步队列中，等待有机会再一次获取到锁，从而使得调用wait()方法的线程能够从wait()方法处退出。调用notify后，当前线程不会马上释放该对象锁，要等到程序退出同步块后，当前线程才会释放锁。\n\n\nnotifyAll\n该方法与 notify ()方法的工作方式相同，重要的一点差异是：\nnotifyAll 使所有原来在该对象上 wait 的线程统统退出WAITTING状态，使得他们全部从等待队列中移入到同步队列中去，等待下一次能够有机会获取到对象监视器锁。\n\n\n1.2 wait/notify消息通知潜在的一些问题##\n1.notify早期通知\nnotify 通知的遗漏很容易理解，即 threadA 还没开始 wait 的时候，threadB 已经 notify 了，这样，threadB 通知是没有任何响应的，当 threadB 退出 synchronized 代码块后，threadA 再开始 wait，便会一直阻塞等待，直到被别的线程打断。比如在下面的示例代码中，就模拟出notify早期通知带来的问题：\npublic class EarlyNotify {\n\n    private static String lockObject = \"\";\n\n    public static void main(String[] args) {\n        WaitThread waitThread = new WaitThread(lockObject);\n        NotifyThread notifyThread = new NotifyThread(lockObject);\n        notifyThread.start();\n        try {\n            Thread.sleep(3000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        waitThread.start();\n    }\n\n    static class WaitThread extends Thread {\n        private String lock;\n\n        public WaitThread(String lock) {\n            this.lock = lock;\n        }\n\n        @Override\n        public void run() {\n            synchronized (lock) {\n                try {\n                    System.out.println(Thread.currentThread().getName() + \"  进去代码块\");\n                    System.out.println(Thread.currentThread().getName() + \"  开始wait\");\n                    lock.wait();\n                    System.out.println(Thread.currentThread().getName() + \"   结束wait\");\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n\n    static class NotifyThread extends Thread {\n        private String lock;\n\n        public NotifyThread(String lock) {\n            this.lock = lock;\n        }\n\n        @Override\n        public void run() {\n            synchronized (lock) {\n                System.out.println(Thread.currentThread().getName() + \"  进去代码块\");\n                System.out.println(Thread.currentThread().getName() + \"  开始notify\");\n                lock.notify();\n                System.out.println(Thread.currentThread().getName() + \"   结束开始notify\");\n            }\n        }\n    }\n}\n\n示例中开启了**两个线程，一个是WaitThread，另一个是NotifyThread。NotifyThread会先启动，先调用notify方法。然后WaitThread线程才启动，调用wait方法，但是由于通知过了，wait方法就无法再获取到相应的通知，因此WaitThread会一直在wait方法出阻塞，这种现象就是通知过早的现象。**针对这种现象，解决方法，一般是添加一个状态标志，让waitThread调用wait方法前先判断状态是否已经改变了没，如果通知早已发出的话，WaitThread就不再去wait。对上面的代码进行更正：\npublic class EarlyNotify {\n\n    private static String lockObject = \"\";\n    private static boolean isWait = true;\n\n    public static void main(String[] args) {\n        WaitThread waitThread = new WaitThread(lockObject);\n        NotifyThread notifyThread = new NotifyThread(lockObject);\n        notifyThread.start();\n        try {\n            Thread.sleep(3000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        waitThread.start();\n    }\n\n    static class WaitThread extends Thread {\n        private String lock;\n\n        public WaitThread(String lock) {\n            this.lock = lock;\n        }\n\n        @Override\n        public void run() {\n            synchronized (lock) {\n                try {\n                    while (isWait) {\n                        System.out.println(Thread.currentThread().getName() + \"  进去代码块\");\n                        System.out.println(Thread.currentThread().getName() + \"  开始wait\");\n                        lock.wait();\n                        System.out.println(Thread.currentThread().getName() + \"   结束wait\");\n                    }\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n\n    static class NotifyThread extends Thread {\n        private String lock;\n\n        public NotifyThread(String lock) {\n            this.lock = lock;\n        }\n\n        @Override\n        public void run() {\n            synchronized (lock) {\n                System.out.println(Thread.currentThread().getName() + \"  进去代码块\");\n                System.out.println(Thread.currentThread().getName() + \"  开始notify\");\n                lock.notifyAll();\n                isWait = false;\n                System.out.println(Thread.currentThread().getName() + \"   结束开始notify\");\n            }\n        }\n    }\n}\n\n这段代码只是增加了一个isWait状态变量，NotifyThread调用notify方法后会对状态变量进行更新，在WaitThread中调用wait方法之前会先对状态变量进行判断，在该示例中，调用notify后将状态变量isWait改变为false，因此，在WaitThread中while对isWait判断后就不会执行wait方法，从而避免了Notify过早通知造成遗漏的情况。\n总结：在使用线程的等待/通知机制时，一般都要配合一个 boolean 变量值（或者其他能够判断真假的条件），在 notify 之前改变该 boolean 变量的值，让 wait 返回后能够退出 while 循环（一般都要在 wait 方法外围加一层 while 循环，以防止早期通知），或在通知被遗漏后，不会被阻塞在 wait 方法处。这样便保证了程序的正确性。\n2.等待wait的条件发生变化\n如果线程在等待时接受到了通知，但是之后等待的条件发生了变化，并没有再次对等待条件进行判断，也会导致程序出现错误。\n下面用一个例子来说明这种情况\npublic class ConditionChange {\nprivate static List<String> lockObject = new ArrayList();\n\n\npublic static void main(String[] args) {\n    Consumer consumer1 = new Consumer(lockObject);\n    Consumer consumer2 = new Consumer(lockObject);\n    Productor productor = new Productor(lockObject);\n    consumer1.start();\n    consumer2.start();\n    productor.start();\n}\n\n\nstatic class Consumer extends Thread {\n    private List<String> lock;\n\n    public Consumer(List lock) {\n        this.lock = lock;\n    }\n\n    @Override\n    public void run() {\n        synchronized (lock) {\n            try {\n                //这里使用if的话，就会存在wait条件变化造成程序错误的问题\n                if (lock.isEmpty()) {\n                    System.out.println(Thread.currentThread().getName() + \" list为空\");\n                    System.out.println(Thread.currentThread().getName() + \" 调用wait方法\");\n                    lock.wait();\n                    System.out.println(Thread.currentThread().getName() + \"  wait方法结束\");\n                }\n                String element = lock.remove(0);\n                System.out.println(Thread.currentThread().getName() + \" 取出第一个元素为：\" + element);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n}\n\n\nstatic class Productor extends Thread {\n    private List<String> lock;\n\n    public Productor(List lock) {\n        this.lock = lock;\n    }\n\n    @Override\n    public void run() {\n        synchronized (lock) {\n            System.out.println(Thread.currentThread().getName() + \" 开始添加元素\");\n            lock.add(Thread.currentThread().getName());\n            lock.notifyAll();\n        }\n    }\n\n}\n}\n\n会报异常：\n\nException in thread \"Thread-1\" Thread-0 list为空\nThread-0 调用wait方法\nThread-1 list为空\nThread-1 调用wait方法\nThread-2 开始添加元素\nThread-1  wait方法结束\njava.lang.IndexOutOfBoundsException: Index: 0, Size: 0\n\n异常原因分析：在这个例子中一共开启了3个线程，Consumer1,Consumer2以及Productor。首先Consumer1调用了wait方法后，线程处于了WAITTING状态，并且将对象锁释放出来。因此，Consumer2能够获取对象锁，从而进入到同步代块中，当执行到wait方法时，同样的也会释放对象锁。因此，productor能够获取到对象锁，进入到同步代码块中，向list中插入数据后，通过notifyAll方法通知处于WAITING状态的Consumer1和Consumer2线程。consumer1得到对象锁后，从wait方法出退出，删除了一个元素让List为空，方法执行结束，退出同步块，释放掉对象锁。这个时候Consumer2获取到对象锁后，从wait方法退出，继续往下执行，这个时候Consumer2再执行lock.remove(0);就会出错，因为List由于Consumer1删除一个元素之后已经为空了。\n**解决方案：**通过上面的分析，可以看出Consumer2报异常是因为线程从wait方法退出之后没有再次对wait条件进行判断，因此，此时的wait条件已经发生了变化。解决办法就是，在wait退出之后再对条件进行判断即可。\npublic class ConditionChange {\nprivate static List<String> lockObject = new ArrayList();\n\n\npublic static void main(String[] args) {\n    Consumer consumer1 = new Consumer(lockObject);\n    Consumer consumer2 = new Consumer(lockObject);\n    Productor productor = new Productor(lockObject);\n    consumer1.start();\n    consumer2.start();\n    productor.start();\n}\n\n\nstatic class Consumer extends Thread {\n    private List<String> lock;\n\n    public Consumer(List lock) {\n        this.lock = lock;\n    }\n\n    @Override\n    public void run() {\n        synchronized (lock) {\n            try {\n                //这里使用if的话，就会存在wait条件变化造成程序错误的问题\n                while (lock.isEmpty()) {\n                    System.out.println(Thread.currentThread().getName() + \" list为空\");\n                    System.out.println(Thread.currentThread().getName() + \" 调用wait方法\");\n                    lock.wait();\n                    System.out.println(Thread.currentThread().getName() + \"  wait方法结束\");\n                }\n                String element = lock.remove(0);\n                System.out.println(Thread.currentThread().getName() + \" 取出第一个元素为：\" + element);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n}\n\n\nstatic class Productor extends Thread {\n    private List<String> lock;\n\n    public Productor(List lock) {\n        this.lock = lock;\n    }\n\n    @Override\n    public void run() {\n        synchronized (lock) {\n            System.out.println(Thread.currentThread().getName() + \" 开始添加元素\");\n            lock.add(Thread.currentThread().getName());\n            lock.notifyAll();\n        }\n    }\n\n}\n}\n\n上面的代码与之前的代码仅仅只是将 wait 外围的 if 语句改为 while 循环即可，这样当 list 为空时，线程便会继续等待，而不会继续去执行删除 list 中元素的代码。\n总结：在使用线程的等待/通知机制时，一般都要在 while 循环中调用 wait()方法，因此xuy配合使用一个 boolean 变量（或其他能判断真假的条件，如本文中的 list.isEmpty()），满足 while 循环的条件时，进入 while 循环，执行 wait()方法，不满足 while 循环的条件时，跳出循环，执行后面的代码。\n3. “假死”状态\n现象：如果是多消费者和多生产者情况，如果使用notify方法可能会出现“假死”的情况，即唤醒的是同类线程。\n原因分析：假设当前多个生产者线程会调用wait方法阻塞等待，当其中的生产者线程获取到对象锁之后使用notify通知处于WAITTING状态的线程，如果唤醒的仍然是生产者线程，就会造成所有的生产者线程都处于等待状态。\n解决办法：将notify方法替换成notifyAll方法，如果使用的是lock的话，就将signal方法替换成signalAll方法。\n\n总结\n\n在Object提供的消息通知机制应该遵循如下这些条件：\n\n永远在while循环中对条件进行判断而不是if语句中进行wait条件的判断；\n使用NotifyAll而不是使用notify。\n\n基本的使用范式如下：\n// The standard idiom for calling the wait method in Java \nsynchronized (sharedObject) { \n    while (condition) { \n    sharedObject.wait(); \n        // (Releases lock, and reacquires on wakeup) \n    } \n    // do action based upon condition e.g. take or put into queue \n}\n\n1.3 wait/notifyAll实现生产者-消费者\n利用wait/notifyAll实现生产者和消费者代码如下：\npublic class ProductorConsumer {\n\n\npublic static void main(String[] args) {\n\n    LinkedList linkedList = new LinkedList();\n    ExecutorService service = Executors.newFixedThreadPool(15);\n    for (int i = 0; i < 5; i++) {\n        service.submit(new Productor(linkedList, 8));\n    }\n\n    for (int i = 0; i < 10; i++) {\n        service.submit(new Consumer(linkedList));\n    }\n\n}\n\nstatic class Productor implements Runnable {\n\n    private List<Integer> list;\n    private int maxLength;\n\n    public Productor(List list, int maxLength) {\n        this.list = list;\n        this.maxLength = maxLength;\n    }\n\n    @Override\n    public void run() {\n        while (true) {\n            synchronized (list) {\n                try {\n                    while (list.size() == maxLength) {\n                        System.out.println(\"生产者\" + Thread.currentThread().getName() + \"  list以达到最大容量，进行wait\");\n                        list.wait();\n                        System.out.println(\"生产者\" + Thread.currentThread().getName() + \"  退出wait\");\n                    }\n                    Random random = new Random();\n                    int i = random.nextInt();\n                    System.out.println(\"生产者\" + Thread.currentThread().getName() + \" 生产数据\" + i);\n                    list.add(i);\n                    list.notifyAll();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n\n        }\n    }\n}\n\n\nstatic class Consumer implements Runnable {\n\n    private List<Integer> list;\n\n    public Consumer(List list) {\n        this.list = list;\n    }\n\n    @Override\n    public void run() {\n        while (true) {\n            synchronized (list) {\n                try {\n                    while (list.isEmpty()) {\n                        System.out.println(\"消费者\" + Thread.currentThread().getName() + \"  list为空，进行wait\");\n                        list.wait();\n                        System.out.println(\"消费者\" + Thread.currentThread().getName() + \"  退出wait\");\n                    }\n                    Integer element = list.remove(0);\n                    System.out.println(\"消费者\" + Thread.currentThread().getName() + \"  消费数据：\" + element);\n                    list.notifyAll();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n\n}\n\n输出结果：\n\n生产者pool-1-thread-1 生产数据-232820990\n生产者pool-1-thread-1 生产数据1432164130\n生产者pool-1-thread-1 生产数据1057090222\n生产者pool-1-thread-1 生产数据1201395916\n生产者pool-1-thread-1 生产数据482766516\n生产者pool-1-thread-1  list以达到最大容量，进行wait\n消费者pool-1-thread-15  退出wait\n消费者pool-1-thread-15  消费数据：1237535349\n消费者pool-1-thread-15  消费数据：-1617438932\n消费者pool-1-thread-15  消费数据：-535396055\n消费者pool-1-thread-15  消费数据：-232820990\n消费者pool-1-thread-15  消费数据：1432164130\n消费者pool-1-thread-15  消费数据：1057090222\n消费者pool-1-thread-15  消费数据：1201395916\n消费者pool-1-thread-15  消费数据：482766516\n消费者pool-1-thread-15  list为空，进行wait\n生产者pool-1-thread-5  退出wait\n生产者pool-1-thread-5 生产数据1442969724\n生产者pool-1-thread-5 生产数据1177554422\n生产者pool-1-thread-5 生产数据-133137235\n生产者pool-1-thread-5 生产数据324882560\n生产者pool-1-thread-5 生产数据2065211573\n生产者pool-1-thread-5 生产数据253569900\n生产者pool-1-thread-5 生产数据571277922\n生产者pool-1-thread-5 生产数据1622323863\n生产者pool-1-thread-5  list以达到最大容量，进行wait\n消费者pool-1-thread-10  退出wait\n\n2. 使用Lock中Condition的await/signalAll实现生产者-消费者\n参照Object的wait和notify/notifyAll方法，Condition也提供了同样的方法：\n\n针对wait方法\n\nvoid await() throws InterruptedException：当前线程进入等待状态，如果其他线程调用condition的signal或者signalAll方法并且当前线程获取Lock从await方法返回，如果在等待状态中被中断会抛出被中断异常；\nlong awaitNanos(long nanosTimeout)：当前线程进入等待状态直到被通知，中断或者超时；\nboolean await(long time, TimeUnit unit)throws InterruptedException：同第二种，支持自定义时间单位\nboolean awaitUntil(Date deadline) throws InterruptedException：当前线程进入等待状态直到被通知，中断或者到了某个时间\n\n针对notify方法\n\nvoid signal()：唤醒一个等待在condition上的线程，将该线程从等待队列中转移到同步队列中，如果在同步队列中能够竞争到Lock则可以从等待方法中返回。\nvoid signalAll()：与1的区别在于能够唤醒所有等待在condition上的线程\n也就是说wait--->await，notify---->Signal。另外，关于lock中condition消息通知的原理解析可以看这篇文章。\n如果采用lock中Conditon的消息通知原理来实现生产者-消费者问题，原理同使用wait/notifyAll一样。直接上代码：\npublic class ProductorConsumer {\n\nprivate static ReentrantLock lock = new ReentrantLock();\nprivate static Condition full = lock.newCondition();\nprivate static Condition empty = lock.newCondition();\n\npublic static void main(String[] args) {\n    LinkedList linkedList = new LinkedList();\n    ExecutorService service = Executors.newFixedThreadPool(15);\n    for (int i = 0; i < 5; i++) {\n        service.submit(new Productor(linkedList, 8, lock));\n    }\n    for (int i = 0; i < 10; i++) {\n        service.submit(new Consumer(linkedList, lock));\n    }\n\n}\n\nstatic class Productor implements Runnable {\n\n    private List<Integer> list;\n    private int maxLength;\n    private Lock lock;\n\n    public Productor(List list, int maxLength, Lock lock) {\n        this.list = list;\n        this.maxLength = maxLength;\n        this.lock = lock;\n    }\n\n    @Override\n    public void run() {\n        while (true) {\n            lock.lock();\n            try {\n                while (list.size() == maxLength) {\n                    System.out.println(\"生产者\" + Thread.currentThread().getName() + \"  list以达到最大容量，进行wait\");\n                    full.await();\n                    System.out.println(\"生产者\" + Thread.currentThread().getName() + \"  退出wait\");\n                }\n                Random random = new Random();\n                int i = random.nextInt();\n                System.out.println(\"生产者\" + Thread.currentThread().getName() + \" 生产数据\" + i);\n                list.add(i);\n                empty.signalAll();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            } finally {\n                lock.unlock();\n            }\n        }\n    }\n}\n\n\nstatic class Consumer implements Runnable {\n\n    private List<Integer> list;\n    private Lock lock;\n\n    public Consumer(List list, Lock lock) {\n        this.list = list;\n        this.lock = lock;\n    }\n\n    @Override\n    public void run() {\n        while (true) {\n            lock.lock();\n            try {\n                while (list.isEmpty()) {\n                    System.out.println(\"消费者\" + Thread.currentThread().getName() + \"  list为空，进行wait\");\n                    empty.await();\n                    System.out.println(\"消费者\" + Thread.currentThread().getName() + \"  退出wait\");\n                }\n                Integer element = list.remove(0);\n                System.out.println(\"消费者\" + Thread.currentThread().getName() + \"  消费数据：\" + element);\n                full.signalAll();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            } finally {\n                lock.unlock();\n            }\n        }\n    }\n}\n\n}\n\n输出结果：\n\n消费者pool-1-thread-9  消费数据：1146627506\n消费者pool-1-thread-9  消费数据：1508001019\n消费者pool-1-thread-9  消费数据：-600080565\n消费者pool-1-thread-9  消费数据：-1000305429\n消费者pool-1-thread-9  消费数据：-1270658620\n消费者pool-1-thread-9  消费数据：1961046169\n消费者pool-1-thread-9  消费数据：-307680655\n消费者pool-1-thread-9  list为空，进行wait\n消费者pool-1-thread-13  退出wait\n消费者pool-1-thread-13  list为空，进行wait\n消费者pool-1-thread-10  退出wait\n生产者pool-1-thread-5  退出wait\n生产者pool-1-thread-5 生产数据-892558288\n生产者pool-1-thread-5 生产数据-1917220008\n生产者pool-1-thread-5 生产数据2146351766\n生产者pool-1-thread-5 生产数据452445380\n生产者pool-1-thread-5 生产数据1695168334\n生产者pool-1-thread-5 生产数据1979746693\n生产者pool-1-thread-5 生产数据-1905436249\n生产者pool-1-thread-5 生产数据-101410137\n生产者pool-1-thread-5  list以达到最大容量，进行wait\n生产者pool-1-thread-1  退出wait\n生产者pool-1-thread-1  list以达到最大容量，进行wait\n生产者pool-1-thread-4  退出wait\n生产者pool-1-thread-4  list以达到最大容量，进行wait\n生产者pool-1-thread-2  退出wait\n生产者pool-1-thread-2  list以达到最大容量，进行wait\n生产者pool-1-thread-3  退出wait\n生产者pool-1-thread-3  list以达到最大容量，进行wait\n消费者pool-1-thread-9  退出wait\n消费者pool-1-thread-9  消费数据：-892558288\n\n3. 使用BlockingQueue实现生产者-消费者\n由于BlockingQueue内部实现就附加了两个阻塞操作。即当队列已满时，阻塞向队列中插入数据的线程，直至队列中未满；当队列为空时，阻塞从队列中获取数据的线程，直至队列非空时为止。关于BlockingQueue更多细节可以看这篇文章。可以利用BlockingQueue实现生产者-消费者为题，阻塞队列完全可以充当共享数据区域，就可以很好的完成生产者和消费者线程之间的协作。\npublic class ProductorConsumer {\n\n    private static LinkedBlockingQueue<Integer> queue = new LinkedBlockingQueue<>();\n\n    public static void main(String[] args) {\n        ExecutorService service = Executors.newFixedThreadPool(15);\n        for (int i = 0; i < 5; i++) {\n            service.submit(new Productor(queue));\n        }\n        for (int i = 0; i < 10; i++) {\n            service.submit(new Consumer(queue));\n        }\n    }\n\n\n    static class Productor implements Runnable {\n\n        private BlockingQueue queue;\n\n        public Productor(BlockingQueue queue) {\n            this.queue = queue;\n        }\n\n        @Override\n        public void run() {\n            try {\n                while (true) {\n                    Random random = new Random();\n                    int i = random.nextInt();\n                    System.out.println(\"生产者\" + Thread.currentThread().getName() + \"生产数据\" + i);\n                    queue.put(i);\n                }\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    static class Consumer implements Runnable {\n        private BlockingQueue queue;\n\n        public Consumer(BlockingQueue queue) {\n            this.queue = queue;\n        }\n\n        @Override\n        public void run() {\n            try {\n                while (true) {\n                    Integer element = (Integer) queue.take();\n                    System.out.println(\"消费者\" + Thread.currentThread().getName() + \"正在消费数据\" + element);\n                }\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n}\n\n\n输出结果：\n\n消费者pool-1-thread-7正在消费数据1520577501\n生产者pool-1-thread-4生产数据-127809610\n消费者pool-1-thread-8正在消费数据504316513\n生产者pool-1-thread-2生产数据1994678907\n消费者pool-1-thread-11正在消费数据1967302829\n生产者pool-1-thread-1生产数据369331507\n消费者pool-1-thread-9正在消费数据1994678907\n生产者pool-1-thread-2生产数据-919544017\n消费者pool-1-thread-12正在消费数据-127809610\n生产者pool-1-thread-4生产数据1475197572\n消费者pool-1-thread-14正在消费数据-893487914\n生产者pool-1-thread-3生产数据906921688\n消费者pool-1-thread-6正在消费数据-1292015016\n生产者pool-1-thread-5生产数据-652105379\n生产者pool-1-thread-5生产数据-1622505717\n生产者pool-1-thread-3生产数据-1350268764\n消费者pool-1-thread-7正在消费数据906921688\n生产者pool-1-thread-4生产数据2091628867\n消费者pool-1-thread-13正在消费数据1475197572\n消费者pool-1-thread-15正在消费数据-919544017\n生产者pool-1-thread-2生产数据564860122\n生产者pool-1-thread-2生产数据822954707\n消费者pool-1-thread-14正在消费数据564860122\n消费者pool-1-thread-10正在消费数据369331507\n生产者pool-1-thread-1生产数据-245820912\n消费者pool-1-thread-6正在消费数据822954707\n生产者pool-1-thread-2生产数据1724595968\n生产者pool-1-thread-2生产数据-1151855115\n消费者pool-1-thread-12正在消费数据2091628867\n生产者pool-1-thread-4生产数据-1774364499\n生产者pool-1-thread-4生产数据2006106757\n消费者pool-1-thread-14正在消费数据-1774364499\n生产者pool-1-thread-3生产数据-1070853639\n消费者pool-1-thread-9正在消费数据-1350268764\n消费者pool-1-thread-11正在消费数据-1622505717\n生产者pool-1-thread-5生产数据355412953\n\n可以看出，使用BlockingQueue来实现生产者-消费者很简洁，这正是利用了BlockingQueue插入和获取数据附加阻塞操作的特性。\n关于生产者-消费者实现的三中方式，到这里就全部总结出来，如果觉得不错的话，请点赞，也算是给我的鼓励，在此表示感谢！\n', null, null, null, '掘金', '8300a73a-5b41-11e8-ac35-000c29753dbb');

-- ----------------------------
-- Table structure for `question`
-- ----------------------------
DROP TABLE IF EXISTS `question`;
CREATE TABLE `question` (
  `title` varchar(200) DEFAULT NULL,
  `Id` varchar(50) NOT NULL,
  `Content` varchar(10000) DEFAULT NULL,
  `SupportCnt` int(11) DEFAULT '0',
  `OpposeCnt` int(11) DEFAULT '0',
  `CommentTo` varchar(50) DEFAULT NULL,
  `time` varchar(50) DEFAULT NULL COMMENT '创建时间',
  `UserId` varchar(50) DEFAULT NULL,
  `hits` int(11) NOT NULL DEFAULT '0' COMMENT '浏览量',
  `stick` int(11) NOT NULL DEFAULT '0' COMMENT '置顶',
  `comment` int(11) NOT NULL DEFAULT '0' COMMENT '回答数',
  `status` int(11) NOT NULL DEFAULT '0' COMMENT '加精',
  `accept` varchar(50) DEFAULT NULL COMMENT '采纳',
  `fid` varchar(50) DEFAULT NULL,
  `uname` varchar(50) DEFAULT NULL,
  `frompic` varchar(255) DEFAULT NULL,
  `filename` varchar(255) DEFAULT NULL,
  `filepath` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`Id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of question
-- ----------------------------
INSERT INTO `question` VALUES ('C++资料', '77c3c00e-6a9f-4854-803c-653d5c3d8bc1', 'c++学习', '0', '0', null, '2018-05-20 16:29:33', '456', '2', '0', '0', '0', null, '6ddee1d8-8957-41c7-8554-21a0104c7690', 'LM', 'http://192.168.202.200/group1/M00/00/00/wKjKyFr_8IaAEbYGAACrDL-lp34754.jpg', null, null);
INSERT INTO `question` VALUES ('我的大学生活', '9bffb540-5ef1-47c5-9f07-02f2f5c27528', '<div>\n	作者：Dwzb<br />\n链接：https://www.zhihu.com/question/30970961/answer/60808450<br />\n来源：知乎<br />\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br />\n	<div>\n		<p>\n			本人2014级本科生，当初上大学之前挺迷茫的，不知道大学生活是什么样的，以至于到大学之后什么都不懂，错过了很多机会，非常可惜。所以希望这篇回答对即将上大学的学生有所帮助。（以厦门大学为例，可能和有些学校不一样，但是都大同小异）\n		</p>\n		<p>\n			大学生活我想分两个方面来说：1.大学日常生活及课程设置2.大学生活应该怎样过。\n		</p>\n		<p>\n			1.大学日常生活和课程设置\n		</p>\n		<p>\n			先纠正两个观点\n		</p>\n		<p>\n			（1）初中老师曾对我们说过，熬过这几年，大学就是过神仙般的日子。这对某些人想在大学混日子的人而言可能是对的，但是对于一个希望从事 大学学习专业的工作 的人来说，这绝对是错的。\n		</p>\n		<p>\n			（2）有人说，大学时可以经常出去玩，这个观点应该说是相对于高中比较多，但也不多，一般也只是在周末或放假才能出去，或者是平时某天课少偶尔出去，有时会和同学去校外餐厅吃吃饭。大部分时间都是呆在宿舍。一般也就是几点一线，宿舍，部门活动和开会或做志愿者，图书馆，餐厅。这些基本上占据了周一到周五和大部分周末（因为部门活动一般在周末才能保证大家都有时间）。\n		</p>\n		<p>\n			大学课程是这样的：\n		</p>\n<br />\n		<p>\n			（由于不知道为什么图片发不上去，我就口述了）就是周一到周五的下面这些时间段中的某些会有课，一般每周是十到十五大节，但是一些学院就会比较多，像建筑每周会有20大节，只要试着排一排就知道这课是多么的多。（原来贴的是一张有17大节课的课表）\n		</p>\n		<p>\n			12节  8:00-9:40\n		</p>\n		<p>\n			34节  10:10-11:50\n		</p>\n		<p>\n			56节  2:30-4:10\n		</p>\n		<p>\n			78节  4:40-6:20\n		</p>\n		<p>\n			91011节7:10-9:45\n		</p>\n<br />\n		<p>\n			大学的班级和高中也是不一样的，比如你们学院120人，入学时会分成每班60人，不是这个班一起上的课。学校比如会安排两个老师上这门课，每班60人，是这120人自己去选自己要哪个老师教，选的老师不一样，课的时间地点可能不一样。学校最初分的班只是刚入学分班好管理，且通知事情方便，一般有什么通知都是这个班的qq群通知的。\n		</p>\n		<p>\n			上课的时候就是看自己的课表，什么时候有课什么时候去教学楼（学校里有几个专门用来上课的楼）上，没课的时间一般待在宿舍或有的同学去图书馆或教学楼没人上课的教室自习。待在宿舍可能会玩游戏、看视频、学习、聊天等。\n		</p>\n		<p>\n			看看上面的课表，你算一算时间，会发现你的工作日剩余时间其实并不多，但是其实上图的课算是比较多的了，正常是再砍掉四五大节吧，但这主要看你选的专业，如果选上了医学、建筑这样的专业，课比这都多。有的还修双学位，就是周末还要上课。你还要完成作业，所以你的课余时间并不多。\n		</p>\n		<p>\n			大学上课每次课都是新课，差不多每次课讲一节，只有到期中或期末有的课会有习题课，有的课有期中考试，有的没有，期末考试一天最多考一门，课多的话可能一周天天有考试，所以那段时间叫考试周。因为讲课进度很快，所以很难学的像高中那么精，所以考试题也不会考那么深，一般把书后习题弄懂就能应付考试了，考试周每天才考最多2个小时，所以复习时间还是很充裕的，可以找学长学姐要往年考试的卷子，做几套就好了，还有较大几率碰到原题，除非老师推荐，一般不需要自己再找题做，也没有那么多时间。\n		</p>\n		<p>\n			大学刚开始学校可能会通知到这到那拿东西、听宣讲会等琐碎的事，一些生活必需品也逐渐买全，还要办宽带、熟悉校园等。宣讲会除了讲注意事项等生活问题，也可能会讲关于留学的一些计划，所以你应提早决定是否要出国，选择要不要报名一些项目。\n		</p>\n		<p>\n			有的宿舍比较团结，什么事都一起做，也有的宿舍人人都有自己的一个圈子。\n		</p>\n		<p>\n			刚开学会有一些学生会部门在招募，还有各个球队招新生，还有搞一些众筹之类的活动的，这些就看你自己的兴趣选择性参加。最好还是报几个，以后可能会举办一些活动以免大学生活太单调，一般也就这个时候会大举招募，以后想进机会就少了。\n		</p>\n	</div>\n</div>', '0', '0', null, '2018-05-16 11:14:06', 'e1283cea-fa8b-4562-9c36-df370d4c1feb', '0', '0', '0', '0', null, '39c84611-d107-4da0-964a-7183cc5e1024', '123qwe', 'http://192.168.202.200/group1/M00/00/00/wKjKyFr_8OOAXlxgABA68m4Nglc261.pdf', null, null);
INSERT INTO `question` VALUES ('hahah', 'e0195736-f372-4625-8180-d175d7a4c28c', 'adasdsada', '0', '0', null, '2018-05-16 11:30:37', '789', '9', '0', '0', '0', null, '37be2631-5180-4bde-bc6a-f0e98201173c', 'MM', null, null, null);
INSERT INTO `question` VALUES ('大苏打', 'e35ad00d-a060-464e-a6b0-5114013df518', '萨达', '0', '0', null, '2018-05-20 16:33:08', '456', '0', '0', '0', '0', null, '2d869735-4eeb-4093-aba3-6442840a59af', 'LM', 'http://192.168.202.200/group1/M00/00/00/wKjKyFr_8IaAEbYGAACrDL-lp34754.jpg', null, null);

-- ----------------------------
-- Table structure for `sysconf`
-- ----------------------------
DROP TABLE IF EXISTS `sysconf`;
CREATE TABLE `sysconf` (
  `id` varchar(50) NOT NULL,
  `value` varchar(200) NOT NULL,
  `key` varchar(50) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of sysconf
-- ----------------------------
INSERT INTO `sysconf` VALUES ('8223baeb-a7e9-4932-a64b-d709300473e2', '2.0', 'version');
INSERT INTO `sysconf` VALUES ('c0b07303-6e23-4f89-9570-d6aef0d7b92f', '4305', 'download');

-- ----------------------------
-- Table structure for `tb_user`
-- ----------------------------
DROP TABLE IF EXISTS `tb_user`;
CREATE TABLE `tb_user` (
  `uid` varchar(50) NOT NULL,
  `username` varchar(20) NOT NULL,
  `password` varchar(50) NOT NULL,
  `email` varchar(20) DEFAULT NULL,
  `post` int(11) DEFAULT NULL,
  `sign` varchar(20) DEFAULT NULL,
  `face` varchar(255) DEFAULT NULL,
  `joindate` varchar(50) DEFAULT NULL,
  `lastlogin` varchar(50) DEFAULT NULL,
  `isbest` int(11) DEFAULT NULL,
  `userfav` varchar(255) DEFAULT NULL,
  `userinfo` varchar(255) DEFAULT NULL,
  `userhidden` int(11) DEFAULT NULL,
  `userviews` int(11) DEFAULT NULL,
  `privilege` int(11) DEFAULT NULL,
  `visits` int(11) DEFAULT '0',
  `status` int(11) DEFAULT '0',
  `phone` varchar(50) DEFAULT NULL,
  `city` varchar(50) DEFAULT NULL,
  PRIMARY KEY (`uid`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of tb_user
-- ----------------------------
INSERT INTO `tb_user` VALUES ('123', 'LL', 'ICy5YqxZB1uWSwcVLSNLcA==', '1137770978@qq.com', null, null, null, null, '2018-05-16 11:30:06', null, null, null, null, null, '1', '12', '1', null, null);
INSERT INTO `tb_user` VALUES ('2abe95d2-fa87-4af0-8e3b-b1ca70b9e7b7', 'admin', 'ISMvKXpXpadDiUoOSoAfww==', '1137770978@qq.com', null, null, null, '2018-05-15 13:27:44', '2018-05-21 13:45:14', null, null, null, null, null, '0', '12', '0', '15754334355', null);
INSERT INTO `tb_user` VALUES ('456', 'LM', 'ICy5YqxZB1uWSwcVLSNLcA==', null, null, null, 'http://192.168.202.200/group1/M00/00/00/wKjKyFr_8IaAEbYGAACrDL-lp34754.jpg', null, '2018-05-21 13:45:57', null, null, null, null, null, '1', '12', '1', null, null);
INSERT INTO `tb_user` VALUES ('789', 'MM', 'ICy5YqxZB1uWSwcVLSNLcA==', null, null, null, null, null, '2018-05-17 17:00:47', null, null, null, null, null, '1', '12', '1', null, null);
INSERT INTO `tb_user` VALUES ('e1283cea-fa8b-4562-9c36-df370d4c1feb', '123qwe', 'ICy5YqxZB1uWSwcVLSNLcA==', '1137770978@qq.com', null, 'asdadadsad', 'http://192.168.202.200/group1/M00/00/00/wKjKyFr_8OOAXlxgABA68m4Nglc261.pdf', '2018-05-15 20:23:47', '2018-05-19 17:33:30', null, null, null, null, null, '0', '12', '1', null, 'sdsada');

-- ----------------------------
-- Table structure for `updatelog`
-- ----------------------------
DROP TABLE IF EXISTS `updatelog`;
CREATE TABLE `updatelog` (
  `id` varchar(50) NOT NULL,
  `description` varchar(1000) NOT NULL,
  `version` varchar(20) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of updatelog
-- ----------------------------
